---
title: "Integration for Messaging Channels"
sidebarTitle: Integration Messaging
mode: "wide"
---

## How it Works

An important feature of Botpress Integrations is the ability to connect to messaging channels. Without integrations, it would be impossible to send a message to your bot. This is because, an incoming message in Botpress can only be created by an Integration. Here's a quick overview of how this works:

```mermaid
sequenceDiagram
    actor U as End User
    participant ES as External Service
    participant I as Integration
    participant BP as Botpress
    participant Bot as Bot ðŸ¤–

    U ->>   ES:  Sends Message
    ES ->>  BP:  POST webhook.botpress.cloud/$webhookId
    BP ->>  I:   Forward webhook request
    I ->>   BP:  POST <br/>api.botpress.cloud<br/>/v1/chat/messages
    BP ->>  Bot: Forward created message
    Bot ->> BP:  POST <br/>api.botpress.cloud<br/>/v1/chat/messages
    BP ->>  I:   Forward outgoing messages
    I ->>   ES:  Forward outgoing messages
    ES ->>  U:   Display response
```

Here's a quick breakdown of the sequence:
1. The end user sends a message to an external service (e.g., WhatsApp, Messenger, etc.).
2. The external service forwards the message to Botpress via a webhook. Every integration has a unique way of providing the webhook URL to the external service. For example, Telegram does it using the API, while Slack requires you to set up a webhook URL in the Slack app settings. The webhook ID path parameter is a string that uniquely identifies the pair of an integration and a bot. This ID is different if you install the same integration in multiple different bots.
3. Botpress forwards the webhook request to the integration. The request is also filled with the bot ID and other contextual information.
4. The integration creates a message by calling [the Botpress Runtime API](../../../api-reference/runtime-api/getting-started) located at `api.botpress.cloud/v1/chat`. 

<Note>This API requires every request to be authenticated either as a Bot or an Integration. All messages created by requests sent from an integration are treated as incoming messages since they come from outside of Botpress. The other way around, all messages created by requests sent from a Bot are treated as outgoing messages since they are sent from inside Botpress.</Note>

5. Botpress forwards the created message to the bot.
6. The bot processes the message and sends a response back the Runtime API. Now that the request is authenticated as a bot, the message is treated as an outgoing message.
7. Botpress forwards the outgoing message to the integration.
8. The integration forwards the outgoing message to the external service. This logic is specific to each integration.


## Connect your own Channels

If Botpress does not already provide an integration for the messaging channel of your choice, you can connect it yourself by creating an integration. To do so, follow the [Get Started](./getting-started) page, but this time, instead of choosing the `hello-world` template, choose the `webhook-message` template. 

### Channel Definition

After running the init command and opening the generated directory in your code editor, you will see the following integration definition:

{/* TODO(driftable): This script is subject to changes and should be auto-generated */}
```ts
// integrations.definition.ts
import { z, IntegrationDefinition } from '@botpress/sdk'

export default new IntegrationDefinition({
  name: "webhook-message",
  version: '0.0.1',
  configuration: {
    schema: z.object({
      webhookUrl: z.string().describe('The url to post the bot answers to.'),
    }),
  },
  channels: {
    webhook: {
      conversation: {
        tags: {
          id: { title: 'Conversation ID', description: 'The ID of the conversation in the external service' },
        },
      },
      messages: {
        // this channel only supports text messages
        text: {
          schema: z.object({
            text: z.string(),
          }),
        },
      },
    },
  },
  user: {
    tags: {
      id: { title: 'User ID', description: 'The ID of the user in the external service' },
    },
  },
})
```

Let's break down this data structure:

- The `configuration` property is where you define the configuration schema. In the studio, when you install this integration in your bot, the configuration schema will be used to display a form. In this case, the only configuration option is the `webhookUrl` on which to send the bot responses.

- The `channels` property is where you define the channels that your integration will support. In this case, we are defining a `webhook` channel. An integration can define multiple channels. For example, Github allows conversing with your both on issues and pull requests. Each channel can have its own set of tags and message types.

- The `conversation` property in the channel definition is where you define available tags for the conversation. In this case, we are defining a single tag called `id` that identifies the conversation in the external service. This allows binding the botpress conversation to the external service conversation. When sending outgoing message response, this tag will be used to properly route the message to the external service.

- The `user` property is where you define available tags for the user. In this case, we are defining a single tag called `id` that identifies the user in the external service. This allows binding the botpress user to the external service user. When sending outgoing message response, this tag will be used to properly route the message to the external service.

- The `messages` property in the channel definition is where you define available message types. In this case, we are defining a single message type called `text` that contains a single field called `text`. This allows sending text messages to the external service. You could define multiple message types, for example, `image`, `video`, etc. The SDK exports a record of default message types that are supported in most messaging channels.

### Channel Implementation

The channel implementation looks something like this:

{/* TODO(driftable): This script is subject to changes and should be auto-generated */}
```ts
import * as sdk from '@botpress/sdk'
import axios from 'axios'
import * as bp from '.botpress'

export default new bp.Integration({
  register: async () => {},
  unregister: async () => {},
  actions: {},
  channels: {
    webhook: {
      messages: {
        text: async (props) => {
          /**
           * This is the outgoing message handler. It is called when a bot sends a message to the user.
           */
          const {
            ctx: {
              configuration: { webhookUrl },
            },
            conversation: {
              id: botpressConversationId,
              tags: { id: externalConversationId },
            },
            payload: { text },
          } = props

          props.logger.forBot().debug(`[${botpressConversationId}] sending message "${text}"`)

          const requestBody = {
            conversationId: externalConversationId,
            text,
          }

          await axios.post(webhookUrl, requestBody)
        },
      },
    },
  },
  handler: async (props) => {
    /**
     * This is the incoming request handler. It is called by the external service you are integrating with.
     */
    const {
      client,
      req: { body },
    } = props

    if (!body) {
      return {
        status: 400,
        body: JSON.stringify({ error: 'No body' }),
      }
    }

    let parsedBody: unknown
    try {
      parsedBody = JSON.parse(body)
    } catch {
      return {
        status: 400,
        body: JSON.stringify({ error: 'Invalid JSON Body' }),
      }
    }

    const parseResult = sdk.z
      .object({
        userId: sdk.z.string(),
        conversationId: sdk.z.string(),
        text: sdk.z.string(),
      })
      .safeParse(parsedBody)

    if (!parseResult.success) {
      return {
        status: 400,
        body: JSON.stringify({ error: 'Invalid body' }),
      }
    }

    const { userId, conversationId, text } = parseResult.data

    const { conversation } = await client.getOrCreateConversation({
      channel: 'webhook',
      tags: {
        id: conversationId,
      },
    })

    const { user } = await client.getOrCreateUser({
      tags: {
        id: userId,
      },
    })

    const { message } = await client.createMessage({
      type: 'text',
      conversationId: conversation.id,
      userId: user.id,
      payload: {
        text,
      },
      tags: {},
    })

    const response = {
      message,
    }

    return {
      status: 200,
      body: JSON.stringify(response),
    }
  },
})
```


Let's break down this code:

- The `handler` function is where the incoming request is handled. When you or an external service calls `webhook.botpress.cloud/$webhookId` this is Botpress forwards the request to. The first thing done in this handler is always to parse the HTTP request. Once the request is parsed and validated you can see three consecutive calls made to the runtime API, respectively `getOrCreateConversation`, `getOrCreateUser`, and `createMessage`. This is a very common pattern in Botpress integrations that integrate with a messaging channel. The `getOrCreateConversation` and `getOrCreateUser` operations first check if a conversation or user already exist for the provided tags (here the external ids). If they do, the operations return the existing conversation and user. If they don't, the operations create a new conversation and user with the provided tags. This ensures that subsequent messages from the same user and conversation are routed to the same conversation and user in Botpress. The `createMessage` operation creates a new message in Botpress with the provided payload. This message is then forwarded to the bot for processing.

- The `channels.webhook` property is where you define the outgoing message handlers; i.e. the logic executed when the bot sends a message to the user. In this case, we are defining a single handler for the `text` message type. Here we call the provided webhook with the conversation that was created in the incoming request. It is important here not to confuse the id tag and the conversation id. The id tag is the external id of the conversation in the external service that was provided in the incoming request.

## What's Next?

If you still struggle to understand how integration messaging works or how to connect Botpress with your own messaging channel you can check out the following ressources:

- [The Botpress Github Repo](https://github.com/botpress/botpress). Most of our integrations source code is open source and can be found there.
- [The Runtime API Documentation](../../../api-reference/runtime-api/getting-started). This documentation should repeat a lot of information mentioned here but from the POV of the backend. Using different words might help you understand better how the integration messaging works.
- [The Integration Concepts Page](./concepts). This page contains a more in-depth explanation of the integration concepts and how they work. It should dig deeper in integration concepts including messaging components.
