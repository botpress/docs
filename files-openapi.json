{
  "openapi": "3.0.0",
  "servers": [{ "url": "https://api.botpress.cloud" }],
  "info": { "title": "Botpress API", "description": "API for Botpress Cloud", "version": "1.1.0" },
  "paths": {
    "/v1/files": {
      "put": {
        "operationId": "upsertFile",
        "description": "Creates or updates a file using the `key` parameter as unique identifier. Updating a file will erase the existing content of the file. Upload the file content by sending it in a PUT request to the `uploadUrl` returned in the response.",
        "parameters": [],
        "responses": {
          "200": { "$ref": "#/components/responses/upsertFileResponse" },
          "default": { "$ref": "#/components/responses/upsertFileResponse" }
        },
        "requestBody": { "$ref": "#/components/requestBodies/upsertFileBody" }
      },
      "get": {
        "operationId": "listFiles",
        "description": "List files for bot",
        "parameters": [
          {
            "name": "nextToken",
            "in": "query",
            "description": "Provide the `meta.nextToken` value provided in the last API response to retrieve the next page of results",
            "schema": { "type": "string" }
          },
          {
            "name": "sortField",
            "in": "query",
            "description": "Sort results by this field",
            "schema": { "type": "string", "enum": ["key", "size", "createdAt", "updatedAt", "status"] }
          },
          {
            "name": "sortDirection",
            "in": "query",
            "description": "Sort results in this direction",
            "schema": { "type": "string", "enum": ["asc", "desc"] }
          },
          {
            "name": "tags",
            "in": "query",
            "description": "Filter files by tags. Tags should be passed as a URL-encoded JSON object of key-value pairs that must be present in the tags of a file. An array of multiple string values for the same key are treated as an OR condition. To exclude a value, express it as an object with a nested `not` key with the string or string-array value(s) to exclude.",
            "schema": {}
          },
          {
            "name": "ids",
            "in": "query",
            "description": "Filter files by IDs.",
            "schema": { "type": "array", "items": { "type": "string" }, "maxItems": 50 }
          }
        ],
        "responses": {
          "200": { "$ref": "#/components/responses/listFilesResponse" },
          "default": { "$ref": "#/components/responses/listFilesResponse" }
        }
      }
    },
    "/v1/files/{id}": {
      "delete": {
        "operationId": "deleteFile",
        "description": "Deletes a file.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "File ID or Key",
            "required": true,
            "schema": { "type": "string" }
          }
        ],
        "responses": {
          "200": { "$ref": "#/components/responses/deleteFileResponse" },
          "default": { "$ref": "#/components/responses/deleteFileResponse" }
        }
      },
      "get": {
        "operationId": "getFile",
        "description": "Get file",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "File ID or Key",
            "required": true,
            "schema": { "type": "string" }
          }
        ],
        "responses": {
          "200": { "$ref": "#/components/responses/getFileResponse" },
          "default": { "$ref": "#/components/responses/getFileResponse" }
        }
      },
      "put": {
        "operationId": "updateFileMetadata",
        "description": "Update file metadata, without updating the file content.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "File ID or Key",
            "required": true,
            "schema": { "type": "string" }
          }
        ],
        "responses": {
          "200": { "$ref": "#/components/responses/updateFileMetadataResponse" },
          "default": { "$ref": "#/components/responses/updateFileMetadataResponse" }
        },
        "requestBody": { "$ref": "#/components/requestBodies/updateFileMetadataBody" }
      }
    },
    "/v1/files/{idOrKey}/{destinationKey}": {
      "post": {
        "operationId": "copyFile",
        "description": "Copy file",
        "parameters": [
          {
            "name": "idOrKey",
            "in": "path",
            "description": "File ID or Key",
            "required": true,
            "schema": { "type": "string" }
          },
          {
            "name": "destinationKey",
            "in": "path",
            "description": "The new key of the file. The file key must not be in use already in the destination bot.",
            "required": true,
            "schema": { "type": "string" }
          },
          {
            "name": "x-destination-bot-id",
            "in": "header",
            "description": "The bot ID to copy the file to. You must have permission to create files in the destination bot. If the destination bot ID is omitted, the file will be copied to the same bot the source file belongs to.",
            "schema": { "type": "string" }
          }
        ],
        "responses": {
          "200": { "$ref": "#/components/responses/copyFileResponse" },
          "default": { "$ref": "#/components/responses/copyFileResponse" }
        },
        "requestBody": { "$ref": "#/components/requestBodies/copyFileBody" }
      }
    },
    "/v1/files/search": {
      "get": {
        "operationId": "searchFiles",
        "description": "Search files",
        "parameters": [
          {
            "name": "tags",
            "in": "query",
            "description": "Filter files by tags. Tags should be passed as a URL-encoded JSON object of key-value pairs that must be present in the tags of a file. An array of multiple string values for the same key are treated as an OR condition. To exclude a value, express it as an object with a nested `not` key with the string or string-array value(s) to exclude.",
            "schema": {}
          },
          {
            "name": "query",
            "in": "query",
            "description": "Query expressed in natural language to retrieve matching text passages within all indexed files in the bot using semantical search.",
            "required": true,
            "schema": { "type": "string" }
          },
          {
            "name": "contextDepth",
            "in": "query",
            "description": "The number of neighbor passages to prepend and append as surrounding context to the content of each returned passage (default: 1, minimum: 0, maximum: 10).",
            "schema": { "type": "integer" }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "The maximum number of passages to return.",
            "schema": { "type": "integer" }
          },
          {
            "name": "consolidate",
            "in": "query",
            "description": "Consolidate the results by merging matching passages from the same file into a single passage per file. The consolidated passage will include the matching passages ordered by their original position in the file (rather than by relevance score) and include hierarchical context such as the title/subtitle to which they belong.",
            "schema": { "type": "boolean" }
          },
          {
            "name": "includeBreadcrumb",
            "in": "query",
            "description": "Prepend a breadcrumb to each passage, containing the title and subtitle(s) the passage belongs to in the file. This option is ignored when the `consolidate` option is set to `true`.",
            "schema": { "type": "boolean" }
          }
        ],
        "responses": {
          "200": { "$ref": "#/components/responses/searchFilesResponse" },
          "default": { "$ref": "#/components/responses/searchFilesResponse" }
        }
      }
    },
    "/v1/files/{id}/passages": {
      "get": {
        "operationId": "listFilePassages",
        "description": "List passages for a file",
        "parameters": [
          {
            "name": "nextToken",
            "in": "query",
            "description": "Provide the `meta.nextToken` value provided in the last API response to retrieve the next page of results",
            "schema": { "type": "string" }
          },
          {
            "name": "id",
            "in": "path",
            "description": "File ID or Key",
            "required": true,
            "schema": { "type": "string" }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "The maximum number of passages to return per request (optional, default: 20, max: 200).",
            "schema": { "type": "number" }
          }
        ],
        "responses": {
          "200": { "$ref": "#/components/responses/listFilePassagesResponse" },
          "default": { "$ref": "#/components/responses/listFilePassagesResponse" }
        }
      }
    },
    "/v1/files/tags": {
      "get": {
        "operationId": "listFileTags",
        "description": "List available tags",
        "parameters": [
          {
            "name": "nextToken",
            "in": "query",
            "description": "Provide the `meta.nextToken` value provided in the last API response to retrieve the next page of results",
            "schema": { "type": "string" }
          }
        ],
        "responses": {
          "200": { "$ref": "#/components/responses/listFileTagsResponse" },
          "default": { "$ref": "#/components/responses/listFileTagsResponse" }
        }
      }
    },
    "/v1/files/tags/{tag}/values": {
      "get": {
        "operationId": "listFileTagValues",
        "description": "List available tags",
        "parameters": [
          {
            "name": "nextToken",
            "in": "query",
            "description": "Provide the `meta.nextToken` value provided in the last API response to retrieve the next page of results",
            "schema": { "type": "string" }
          },
          { "name": "tag", "in": "path", "description": "Tag name", "required": true, "schema": { "type": "string" } }
        ],
        "responses": {
          "200": { "$ref": "#/components/responses/listFileTagValuesResponse" },
          "default": { "$ref": "#/components/responses/listFileTagValuesResponse" }
        }
      }
    },
    "/v1/files/knowledge-bases": {
      "post": {
        "operationId": "createKnowledgeBase",
        "description": "Creates a knowledge base for grouping files.",
        "parameters": [],
        "responses": {
          "200": { "$ref": "#/components/responses/createKnowledgeBaseResponse" },
          "default": { "$ref": "#/components/responses/createKnowledgeBaseResponse" }
        },
        "requestBody": { "$ref": "#/components/requestBodies/createKnowledgeBaseBody" }
      },
      "get": {
        "operationId": "listKnowledgeBases",
        "description": "List knowledge bases for bot",
        "parameters": [
          {
            "name": "nextToken",
            "in": "query",
            "description": "Provide the `meta.nextToken` value provided in the last API response to retrieve the next page of results",
            "schema": { "type": "string" }
          }
        ],
        "responses": {
          "200": { "$ref": "#/components/responses/listKnowledgeBasesResponse" },
          "default": { "$ref": "#/components/responses/listKnowledgeBasesResponse" }
        }
      }
    },
    "/v1/files/knowledge-bases/{id}": {
      "delete": {
        "operationId": "deleteKnowledgeBase",
        "description": "Deletes a knowledge base.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Knowledge base ID",
            "required": true,
            "schema": { "type": "string" }
          }
        ],
        "responses": {
          "200": { "$ref": "#/components/responses/deleteKnowledgeBaseResponse" },
          "default": { "$ref": "#/components/responses/deleteKnowledgeBaseResponse" }
        }
      },
      "put": {
        "operationId": "updateKnowledgeBase",
        "description": "Updates a knowledge base.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Knowledge base ID",
            "required": true,
            "schema": { "type": "string" }
          }
        ],
        "responses": {
          "200": { "$ref": "#/components/responses/updateKnowledgeBaseResponse" },
          "default": { "$ref": "#/components/responses/updateKnowledgeBaseResponse" }
        },
        "requestBody": { "$ref": "#/components/requestBodies/updateKnowledgeBaseBody" }
      }
    }
  },
  "components": {
    "schemas": {
      "Bot": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "minLength": 28, "maxLength": 36, "description": "Id of the [Bot](#schema_bot)" },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation date of the [Bot](#schema_bot) in ISO 8601 format"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Updating date of the [Bot](#schema_bot) in ISO 8601 format"
          },
          "signingSecret": {
            "type": "string",
            "maxLength": 2000,
            "description": "Signing secret of the [Bot](#schema_bot)"
          },
          "integrations": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "enabled": { "type": "boolean" },
                "name": {
                  "type": "string",
                  "maxLength": 200,
                  "description": "Name of the [Integration](#schema_integration)"
                },
                "version": {
                  "type": "string",
                  "maxLength": 200,
                  "description": "Version of the [Integration](#schema_integration)"
                },
                "webhookUrl": { "type": "string", "maxLength": 2000 },
                "webhookId": { "type": "string", "maxLength": 200 },
                "identifier": { "type": "string", "maxLength": 2000 },
                "configurationType": { "type": "string", "maxLength": 200, "nullable": true },
                "configuration": { "type": "object", "additionalProperties": true },
                "status": {
                  "type": "string",
                  "enum": [
                    "registration_pending",
                    "registered",
                    "registration_failed",
                    "unregistration_pending",
                    "unregistered",
                    "unregistration_failed"
                  ]
                },
                "statusReason": { "type": "string", "maxLength": 2000, "nullable": true },
                "id": {
                  "type": "string",
                  "minLength": 28,
                  "maxLength": 36,
                  "description": "ID of the [Integration](#schema_integration)"
                },
                "createdAt": {
                  "type": "string",
                  "format": "date-time",
                  "description": "Creation date of the [Integration](#schema_integration) in ISO 8601 format"
                },
                "updatedAt": {
                  "type": "string",
                  "format": "date-time",
                  "description": "Updating date of the [Integration](#schema_integration) in ISO 8601 format"
                },
                "title": {
                  "type": "string",
                  "minLength": 1,
                  "maxLength": 64,
                  "description": "Title of the integration. This is the name that will be displayed in the UI"
                },
                "description": {
                  "type": "string",
                  "maxLength": 256,
                  "description": "Description of the integration. This is the description that will be displayed in the UI"
                },
                "iconUrl": {
                  "type": "string",
                  "description": "URL of the icon of the integration. This is the icon that will be displayed in the UI"
                },
                "public": {
                  "type": "boolean",
                  "description": "Idicates if the integration is public. Public integrations are available to all and cannot be updated without creating a new version."
                },
                "verificationStatus": {
                  "type": "string",
                  "enum": ["unapproved", "pending", "approved", "rejected"],
                  "description": "Status of the integration version verification"
                }
              },
              "required": [
                "enabled",
                "name",
                "version",
                "webhookUrl",
                "webhookId",
                "configurationType",
                "configuration",
                "status",
                "statusReason",
                "id",
                "createdAt",
                "updatedAt",
                "title",
                "description",
                "iconUrl",
                "public",
                "verificationStatus"
              ],
              "additionalProperties": false
            },
            "description": "A mapping of integrations to their configuration"
          },
          "user": {
            "type": "object",
            "properties": {
              "tags": {
                "type": "object",
                "additionalProperties": {
                  "type": "object",
                  "properties": {
                    "title": { "type": "string", "maxLength": 64, "description": "Title of the tag" },
                    "description": { "type": "string", "maxLength": 256, "description": "Description of the tag" }
                  },
                  "description": "Definition of a tag that can be provided on the object",
                  "additionalProperties": false
                }
              }
            },
            "required": ["tags"],
            "description": "User object configuration",
            "additionalProperties": false
          },
          "conversation": {
            "type": "object",
            "properties": {
              "tags": {
                "type": "object",
                "additionalProperties": {
                  "type": "object",
                  "properties": {
                    "title": { "type": "string", "maxLength": 64, "description": "Title of the tag" },
                    "description": { "type": "string", "maxLength": 256, "description": "Description of the tag" }
                  },
                  "description": "Definition of a tag that can be provided on the object",
                  "additionalProperties": false
                }
              }
            },
            "required": ["tags"],
            "description": "Conversation object configuration",
            "additionalProperties": false
          },
          "message": {
            "type": "object",
            "properties": {
              "tags": {
                "type": "object",
                "additionalProperties": {
                  "type": "object",
                  "properties": {
                    "title": { "type": "string", "maxLength": 64, "description": "Title of the tag" },
                    "description": { "type": "string", "maxLength": 256, "description": "Description of the tag" }
                  },
                  "description": "Definition of a tag that can be provided on the object",
                  "additionalProperties": false
                }
              }
            },
            "required": ["tags"],
            "description": "Message object configuration",
            "additionalProperties": false
          },
          "states": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string",
                  "enum": ["conversation", "user", "bot", "task"],
                  "description": "Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)"
                },
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "description": "Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data."
                },
                "expiry": {
                  "type": "number",
                  "minimum": 1,
                  "description": "Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire."
                }
              },
              "required": ["type", "schema"],
              "additionalProperties": false
            },
            "description": "A mapping of states to their definition"
          },
          "configuration": {
            "type": "object",
            "properties": {
              "data": { "type": "object", "additionalProperties": true, "description": "Configuration data" },
              "schema": {
                "type": "object",
                "additionalProperties": true,
                "description": "Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`."
              }
            },
            "required": ["data", "schema"],
            "description": "Configuration of the bot",
            "additionalProperties": false
          },
          "events": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "title": { "type": "string", "maxLength": 64, "description": "Title of the event" },
                "description": { "type": "string", "maxLength": 256, "description": "Description of the event" },
                "schema": { "type": "object", "additionalProperties": true }
              },
              "required": ["schema"],
              "description": "Event Definition",
              "additionalProperties": false
            },
            "description": "Events definition"
          },
          "recurringEvents": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "schedule": {
                  "type": "object",
                  "properties": { "cron": { "type": "string", "maxLength": 200 } },
                  "required": ["cron"],
                  "additionalProperties": false
                },
                "type": { "type": "string", "maxLength": 200 },
                "payload": { "type": "object", "additionalProperties": true },
                "failedAttempts": {
                  "type": "number",
                  "description": "The number of times the recurring event failed to run. This counter resets once the recurring event runs successfully."
                },
                "lastFailureReason": {
                  "type": "string",
                  "maxLength": 2000,
                  "description": "The reason why the recurring event failed to run in the last attempt.",
                  "nullable": true
                }
              },
              "required": ["schedule", "type", "payload", "failedAttempts", "lastFailureReason"],
              "additionalProperties": false
            },
            "description": "Recurring events"
          },
          "subscriptions": {
            "type": "object",
            "properties": {
              "events": {
                "type": "object",
                "additionalProperties": { "type": "object", "additionalProperties": false },
                "nullable": true,
                "description": "Events that the bot is currently subscribed on (ex: \"slack:reactionAdded\"). If null, the bot is subscribed to all events."
              }
            },
            "required": ["events"],
            "description": "Subscriptions of the bot",
            "additionalProperties": false
          },
          "actions": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "title": { "type": "string", "maxLength": 64, "description": "Title of the action" },
                "description": { "type": "string", "maxLength": 256, "description": "Description of the action" },
                "billable": { "type": "boolean" },
                "cacheable": { "type": "boolean" },
                "input": {
                  "type": "object",
                  "properties": { "schema": { "type": "object", "additionalProperties": true } },
                  "required": ["schema"],
                  "additionalProperties": false
                },
                "output": {
                  "type": "object",
                  "properties": { "schema": { "type": "object", "additionalProperties": true } },
                  "required": ["schema"],
                  "additionalProperties": false
                }
              },
              "required": ["input", "output"],
              "description": "Action definition",
              "additionalProperties": false
            },
            "description": "Actions definition"
          },
          "tags": {
            "type": "object",
            "additionalProperties": { "type": "string" },
            "description": "Tags of [Bot](#schema_bot)"
          },
          "name": { "type": "string", "description": "Name of the [Bot](#schema_bot)" },
          "deployedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Last deployment date of the [Bot](#schema_bot) in the ISO 8601 format"
          },
          "dev": {
            "type": "boolean",
            "description": "Indicates if the [Bot](#schema_bot) is a development bot; Development bots run locally and can install dev integrations"
          },
          "createdBy": { "type": "string", "description": "Id of the user that created the bot" },
          "alwaysAlive": {
            "type": "boolean",
            "description": "Indicates if the [Bot](#schema_bot) should be in always alive mode"
          },
          "status": { "type": "string", "enum": ["active", "deploying"], "description": "Status of the bot" },
          "medias": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "url": { "type": "string", "description": "URL of the media file" },
                "name": { "type": "string", "description": "Name of the media file" }
              },
              "required": ["url", "name"]
            },
            "description": "Media files associated with the [Bot](#schema_bot)"
          }
        },
        "required": [
          "id",
          "createdAt",
          "updatedAt",
          "signingSecret",
          "integrations",
          "user",
          "conversation",
          "message",
          "states",
          "configuration",
          "events",
          "recurringEvents",
          "subscriptions",
          "actions",
          "tags",
          "name",
          "dev",
          "alwaysAlive",
          "status",
          "medias"
        ],
        "additionalProperties": false
      },
      "Integration": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "ID of the [Integration](#schema_integration)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation date of the [Integration](#schema_integration) in ISO 8601 format"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Updating date of the [Integration](#schema_integration) in ISO 8601 format"
          },
          "identifier": {
            "type": "object",
            "properties": {
              "fallbackHandlerScript": {
                "type": "string",
                "maxLength": 2000,
                "description": "VRL Script of the [Integration](#schema_integration) to handle incoming requests for a request that doesn't have an identifier"
              },
              "extractScript": {
                "type": "string",
                "maxLength": 2000,
                "description": "VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook often use for OAuth"
              }
            },
            "description": "Global identifier configuration of the [Integration](#schema_integration)",
            "additionalProperties": false
          },
          "sandbox": {
            "type": "object",
            "properties": {
              "identifierExtractScript": {
                "type": "string",
                "maxLength": 2000,
                "description": "VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook used specifically for the sandbox"
              },
              "messageExtractScript": {
                "type": "string",
                "maxLength": 2000,
                "description": "VRL Script of the [Integration](#schema_integration) to extract the message from an incoming webhook used specifically for the sandbox"
              }
            },
            "additionalProperties": false
          },
          "url": {
            "type": "string",
            "maxLength": 2000,
            "description": "URL of the [Integration](#schema_integration)"
          },
          "name": {
            "type": "string",
            "maxLength": 200,
            "description": "Name of the [Integration](#schema_integration)"
          },
          "version": {
            "type": "string",
            "maxLength": 200,
            "description": "Version of the [Integration](#schema_integration)"
          },
          "interfaces": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "id": { "type": "string", "minLength": 28, "maxLength": 36, "description": "ID of the interface" },
                "name": { "type": "string", "maxLength": 200, "description": "Name of the interface" },
                "version": { "type": "string", "maxLength": 200, "description": "Version of the interface" },
                "entities": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "object",
                    "properties": { "name": { "type": "string", "maxLength": 200 } },
                    "required": ["name"],
                    "additionalProperties": false
                  }
                },
                "actions": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "object",
                    "properties": { "name": { "type": "string", "maxLength": 200 } },
                    "required": ["name"],
                    "additionalProperties": false
                  }
                },
                "events": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "object",
                    "properties": { "name": { "type": "string", "maxLength": 200 } },
                    "required": ["name"],
                    "additionalProperties": false
                  }
                },
                "channels": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "object",
                    "properties": { "name": { "type": "string", "maxLength": 200 } },
                    "required": ["name"],
                    "additionalProperties": false
                  }
                }
              },
              "required": ["id", "name", "version", "entities", "actions", "events", "channels"],
              "additionalProperties": false
            }
          },
          "configuration": {
            "type": "object",
            "properties": {
              "title": { "type": "string", "maxLength": 64, "description": "Title of the configuration" },
              "description": { "type": "string", "maxLength": 256, "description": "Description of the configuration" },
              "identifier": {
                "type": "object",
                "properties": {
                  "linkTemplateScript": { "type": "string", "maxLength": 2000 },
                  "required": { "type": "boolean" }
                },
                "required": ["required"],
                "description": "Identifier configuration of the [Integration](#schema_integration)",
                "additionalProperties": false
              },
              "schema": {
                "type": "object",
                "additionalProperties": true,
                "description": "Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`."
              }
            },
            "required": ["identifier", "schema"],
            "description": "Configuration definition",
            "additionalProperties": false
          },
          "configurations": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "title": { "type": "string", "maxLength": 64, "description": "Title of the configuration" },
                "description": {
                  "type": "string",
                  "maxLength": 256,
                  "description": "Description of the configuration"
                },
                "identifier": {
                  "type": "object",
                  "properties": {
                    "linkTemplateScript": { "type": "string", "maxLength": 2000 },
                    "required": { "type": "boolean" }
                  },
                  "required": ["required"],
                  "description": "Identifier configuration of the [Integration](#schema_integration)",
                  "additionalProperties": false
                },
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "description": "Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`."
                }
              },
              "required": ["identifier", "schema"],
              "description": "Configuration definition",
              "additionalProperties": false
            }
          },
          "channels": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "title": { "type": "string", "maxLength": 64, "description": "Title of the channel" },
                "description": { "type": "string", "maxLength": 256, "description": "Description of the channel" },
                "messages": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "object",
                    "properties": { "schema": { "type": "object", "additionalProperties": true } },
                    "required": ["schema"],
                    "description": "Message definition",
                    "additionalProperties": false
                  }
                },
                "conversation": {
                  "type": "object",
                  "properties": {
                    "tags": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "object",
                        "properties": {
                          "title": { "type": "string", "maxLength": 64, "description": "Title of the tag" },
                          "description": { "type": "string", "maxLength": 256, "description": "Description of the tag" }
                        },
                        "description": "Definition of a tag that can be provided on the object",
                        "additionalProperties": false
                      }
                    },
                    "creation": {
                      "type": "object",
                      "properties": {
                        "enabled": { "type": "boolean", "description": "Enable conversation creation" },
                        "requiredTags": {
                          "type": "array",
                          "items": { "type": "string" },
                          "description": "The list of tags that are required to be specified when calling the API directly to create a conversation."
                        }
                      },
                      "required": ["enabled", "requiredTags"],
                      "description": "The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.",
                      "additionalProperties": false
                    }
                  },
                  "required": ["tags", "creation"],
                  "description": "Conversation object configuration",
                  "additionalProperties": false
                },
                "message": {
                  "type": "object",
                  "properties": {
                    "tags": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "object",
                        "properties": {
                          "title": { "type": "string", "maxLength": 64, "description": "Title of the tag" },
                          "description": { "type": "string", "maxLength": 256, "description": "Description of the tag" }
                        },
                        "description": "Definition of a tag that can be provided on the object",
                        "additionalProperties": false
                      }
                    }
                  },
                  "required": ["tags"],
                  "description": "Message object configuration",
                  "additionalProperties": false
                }
              },
              "required": ["messages", "conversation", "message"],
              "description": "Channel definition",
              "additionalProperties": false
            }
          },
          "states": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string",
                  "enum": ["conversation", "user", "integration"],
                  "description": "Type of the [State](#schema_state) (`conversation`, `user` or `integration`)"
                },
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "description": "Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data."
                }
              },
              "required": ["type", "schema"],
              "description": "State definition",
              "additionalProperties": false
            }
          },
          "events": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "title": { "type": "string", "maxLength": 64, "description": "Title of the event" },
                "description": { "type": "string", "maxLength": 256, "description": "Description of the event" },
                "schema": { "type": "object", "additionalProperties": true }
              },
              "required": ["schema"],
              "description": "Event Definition",
              "additionalProperties": false
            }
          },
          "actions": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "title": { "type": "string", "maxLength": 64, "description": "Title of the action" },
                "description": { "type": "string", "maxLength": 256, "description": "Description of the action" },
                "billable": { "type": "boolean" },
                "cacheable": { "type": "boolean" },
                "input": {
                  "type": "object",
                  "properties": { "schema": { "type": "object", "additionalProperties": true } },
                  "required": ["schema"],
                  "additionalProperties": false
                },
                "output": {
                  "type": "object",
                  "properties": { "schema": { "type": "object", "additionalProperties": true } },
                  "required": ["schema"],
                  "additionalProperties": false
                }
              },
              "required": ["input", "output"],
              "description": "Action definition",
              "additionalProperties": false
            }
          },
          "user": {
            "type": "object",
            "properties": {
              "tags": {
                "type": "object",
                "additionalProperties": {
                  "type": "object",
                  "properties": {
                    "title": { "type": "string", "maxLength": 64, "description": "Title of the tag" },
                    "description": { "type": "string", "maxLength": 256, "description": "Description of the tag" }
                  },
                  "description": "Definition of a tag that can be provided on the object",
                  "additionalProperties": false
                }
              },
              "creation": {
                "type": "object",
                "properties": {
                  "enabled": { "type": "boolean", "description": "Enable user creation" },
                  "requiredTags": {
                    "type": "array",
                    "items": { "type": "string" },
                    "description": "The list of tags that are required to be specified when calling the API directly to create a user."
                  }
                },
                "required": ["enabled", "requiredTags"],
                "description": "The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.",
                "additionalProperties": false
              }
            },
            "required": ["tags", "creation"],
            "description": "User object configuration",
            "additionalProperties": false
          },
          "entities": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "title": { "type": "string", "maxLength": 64, "description": "Title of the entity" },
                "description": { "type": "string", "maxLength": 256, "description": "Description of the entity" },
                "schema": { "type": "object", "additionalProperties": true }
              },
              "required": ["schema"],
              "description": "Entity definition",
              "additionalProperties": false
            }
          },
          "dev": {
            "type": "boolean",
            "description": "Indicates if the integration is a development integration; Dev integrations run locally"
          },
          "title": {
            "type": "string",
            "minLength": 1,
            "maxLength": 64,
            "description": "Title of the integration. This is the name that will be displayed in the UI"
          },
          "description": {
            "type": "string",
            "maxLength": 256,
            "description": "Description of the integration. This is the description that will be displayed in the UI"
          },
          "iconUrl": {
            "type": "string",
            "description": "URL of the icon of the integration. This is the icon that will be displayed in the UI"
          },
          "readmeUrl": {
            "type": "string",
            "description": "URL of the readme of the integration. This is the readme that will be displayed in the UI"
          },
          "public": {
            "type": "boolean",
            "description": "Idicates if the integration is public. Public integrations are available to all and cannot be updated without creating a new version."
          },
          "verificationStatus": {
            "type": "string",
            "enum": ["unapproved", "pending", "approved", "rejected"],
            "description": "Status of the integration version verification"
          },
          "secrets": {
            "type": "array",
            "items": { "type": "string" },
            "description": "Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing."
          }
        },
        "required": [
          "id",
          "createdAt",
          "updatedAt",
          "identifier",
          "url",
          "name",
          "version",
          "interfaces",
          "configuration",
          "configurations",
          "channels",
          "states",
          "events",
          "actions",
          "user",
          "entities",
          "dev",
          "title",
          "description",
          "iconUrl",
          "readmeUrl",
          "public",
          "verificationStatus",
          "secrets"
        ],
        "additionalProperties": false
      },
      "Interface": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "ID of the [Interface](#schema_interface)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation date of the [Interface](#schema_interface) in ISO 8601 format"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Updating date of the [Interface](#schema_interface) in ISO 8601 format"
          },
          "name": { "type": "string", "maxLength": 200, "description": "Name of the [Interface](#schema_interface)" },
          "version": {
            "type": "string",
            "maxLength": 200,
            "description": "Version of the [Interface](#schema_interface)"
          },
          "entities": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "title": { "type": "string", "maxLength": 64, "description": "Title of the entity" },
                "description": { "type": "string", "maxLength": 256, "description": "Description of the entity" },
                "schema": { "type": "object", "additionalProperties": true }
              },
              "required": ["schema"],
              "description": "Entity definition",
              "additionalProperties": false
            }
          },
          "events": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "title": { "type": "string", "maxLength": 64, "description": "Title of the event" },
                "description": { "type": "string", "maxLength": 256, "description": "Description of the event" },
                "schema": { "type": "object", "additionalProperties": true }
              },
              "required": ["schema"],
              "description": "Event Definition",
              "additionalProperties": false
            }
          },
          "actions": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "title": { "type": "string", "maxLength": 64, "description": "Title of the action" },
                "description": { "type": "string", "maxLength": 256, "description": "Description of the action" },
                "billable": { "type": "boolean" },
                "cacheable": { "type": "boolean" },
                "input": {
                  "type": "object",
                  "properties": { "schema": { "type": "object", "additionalProperties": true } },
                  "required": ["schema"],
                  "additionalProperties": false
                },
                "output": {
                  "type": "object",
                  "properties": { "schema": { "type": "object", "additionalProperties": true } },
                  "required": ["schema"],
                  "additionalProperties": false
                }
              },
              "required": ["input", "output"],
              "description": "Action definition",
              "additionalProperties": false
            }
          },
          "channels": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "title": { "type": "string", "maxLength": 64, "description": "Title of the channel" },
                "description": { "type": "string", "maxLength": 256, "description": "Description of the channel" },
                "messages": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "object",
                    "properties": { "schema": { "type": "object", "additionalProperties": true } },
                    "required": ["schema"],
                    "description": "Message definition",
                    "additionalProperties": false
                  }
                }
              },
              "required": ["messages"],
              "additionalProperties": false
            }
          },
          "nameTemplate": {
            "type": "object",
            "properties": {
              "script": { "type": "string", "maxLength": 2000 },
              "language": { "type": "string", "maxLength": 200 }
            },
            "required": ["script", "language"],
            "description": "Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.",
            "additionalProperties": false
          }
        },
        "required": ["id", "createdAt", "updatedAt", "name", "version", "entities", "events", "actions", "channels"],
        "additionalProperties": false
      },
      "Plugin": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "ID of the [Plugin](#schema_plugin)"
          },
          "name": { "type": "string", "maxLength": 200, "description": "Name of the [Plugin](#schema_plugin)" },
          "version": { "type": "string", "maxLength": 200, "description": "Version of the [Plugin](#schema_plugin)" },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation date of the [Plugin](#schema_plugin) in ISO 8601 format"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Updating date of the [Plugin](#schema_plugin) in ISO 8601 format"
          },
          "configuration": {
            "type": "object",
            "properties": {
              "title": { "type": "string", "maxLength": 64, "description": "Title of the configuration" },
              "description": { "type": "string", "maxLength": 256, "description": "Description of the configuration" },
              "schema": {
                "type": "object",
                "additionalProperties": true,
                "description": "Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`."
              }
            },
            "required": ["schema"],
            "description": "Configuration definition",
            "additionalProperties": false
          },
          "states": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string",
                  "enum": ["conversation", "user", "bot", "task"],
                  "description": "Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)"
                },
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "description": "Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data."
                },
                "expiry": {
                  "type": "number",
                  "minimum": 1,
                  "description": "Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire."
                }
              },
              "required": ["type", "schema"],
              "additionalProperties": false
            }
          },
          "events": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "title": { "type": "string", "maxLength": 64, "description": "Title of the event" },
                "description": { "type": "string", "maxLength": 256, "description": "Description of the event" },
                "schema": { "type": "object", "additionalProperties": true }
              },
              "required": ["schema"],
              "description": "Event Definition",
              "additionalProperties": false
            }
          },
          "actions": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "title": { "type": "string", "maxLength": 64, "description": "Title of the action" },
                "description": { "type": "string", "maxLength": 256, "description": "Description of the action" },
                "billable": { "type": "boolean" },
                "cacheable": { "type": "boolean" },
                "input": {
                  "type": "object",
                  "properties": { "schema": { "type": "object", "additionalProperties": true } },
                  "required": ["schema"],
                  "additionalProperties": false
                },
                "output": {
                  "type": "object",
                  "properties": { "schema": { "type": "object", "additionalProperties": true } },
                  "required": ["schema"],
                  "additionalProperties": false
                }
              },
              "required": ["input", "output"],
              "description": "Action definition",
              "additionalProperties": false
            }
          },
          "dependencies": {
            "type": "object",
            "properties": {
              "interfaces": {
                "type": "object",
                "additionalProperties": {
                  "type": "object",
                  "properties": {
                    "id": { "type": "string", "minLength": 28, "maxLength": 36 },
                    "name": { "type": "string", "maxLength": 200 },
                    "version": { "type": "string", "maxLength": 200 }
                  },
                  "required": ["id", "name", "version"],
                  "additionalProperties": false
                }
              },
              "integrations": {
                "type": "object",
                "additionalProperties": {
                  "type": "object",
                  "properties": {
                    "id": { "type": "string", "minLength": 28, "maxLength": 36 },
                    "name": { "type": "string", "maxLength": 200 },
                    "version": { "type": "string", "maxLength": 200 }
                  },
                  "required": ["id", "name", "version"],
                  "additionalProperties": false
                }
              }
            },
            "required": ["interfaces", "integrations"],
            "additionalProperties": false
          },
          "user": {
            "type": "object",
            "properties": {
              "tags": {
                "type": "object",
                "additionalProperties": {
                  "type": "object",
                  "properties": {
                    "title": { "type": "string", "maxLength": 64, "description": "Title of the tag" },
                    "description": { "type": "string", "maxLength": 256, "description": "Description of the tag" }
                  },
                  "description": "Definition of a tag that can be provided on the object",
                  "additionalProperties": false
                }
              }
            },
            "required": ["tags"],
            "description": "User object configuration",
            "additionalProperties": false
          },
          "conversation": {
            "type": "object",
            "properties": {
              "tags": {
                "type": "object",
                "additionalProperties": {
                  "type": "object",
                  "properties": {
                    "title": { "type": "string", "maxLength": 64, "description": "Title of the tag" },
                    "description": { "type": "string", "maxLength": 256, "description": "Description of the tag" }
                  },
                  "description": "Definition of a tag that can be provided on the object",
                  "additionalProperties": false
                }
              }
            },
            "required": ["tags"],
            "description": "Conversation object configuration",
            "additionalProperties": false
          },
          "title": {
            "type": "string",
            "minLength": 1,
            "maxLength": 64,
            "description": "Title of the plugin. This is the name that will be displayed in the UI"
          },
          "description": {
            "type": "string",
            "maxLength": 256,
            "description": "Description of the plugin. This is the description that will be displayed in the UI"
          },
          "iconUrl": {
            "type": "string",
            "description": "URL of the icon of the plugin. This is the icon that will be displayed in the UI"
          },
          "readmeUrl": {
            "type": "string",
            "description": "URL of the readme of the plugin. This is the readme that will be displayed in the UI"
          }
        },
        "required": [
          "id",
          "name",
          "version",
          "createdAt",
          "updatedAt",
          "configuration",
          "states",
          "events",
          "actions",
          "dependencies",
          "user",
          "conversation",
          "title",
          "description",
          "iconUrl",
          "readmeUrl"
        ],
        "additionalProperties": false
      },
      "Workspace": {
        "type": "object",
        "properties": {
          "id": { "type": "string" },
          "name": { "type": "string" },
          "ownerId": { "type": "string" },
          "createdAt": { "type": "string" },
          "updatedAt": { "type": "string" },
          "botCount": { "type": "number" },
          "billingVersion": { "type": "string", "enum": ["v1", "v2", "v3"] },
          "plan": { "type": "string", "enum": ["community", "team", "enterprise", "plus"] },
          "blocked": { "type": "boolean" },
          "spendingLimit": { "type": "number" },
          "about": { "default": "", "type": "string" },
          "profilePicture": { "default": "", "type": "string" },
          "contactEmail": { "default": "", "type": "string" },
          "website": { "default": "", "type": "string" },
          "socialAccounts": { "default": [], "type": "array", "items": { "type": "string" } },
          "isPublic": { "type": "boolean" },
          "handle": { "default": "", "type": "string" }
        },
        "required": [
          "id",
          "name",
          "ownerId",
          "createdAt",
          "updatedAt",
          "botCount",
          "billingVersion",
          "plan",
          "blocked",
          "spendingLimit"
        ],
        "title": "updateWorkspaceResponse",
        "additionalProperties": false
      },
      "WorkspaceMember": {
        "type": "object",
        "properties": {
          "id": { "type": "string" },
          "userId": { "type": "string", "format": "uuid" },
          "email": { "type": "string" },
          "createdAt": { "type": "string" },
          "role": { "type": "string", "enum": ["viewer", "billing", "developer", "manager", "administrator", "owner"] },
          "profilePicture": { "type": "string" },
          "displayName": { "type": "string", "maxLength": 100 }
        },
        "required": ["id", "email", "createdAt", "role"],
        "title": "updateWorkspaceMemberResponse",
        "additionalProperties": false
      },
      "Account": {
        "type": "object",
        "properties": {
          "id": { "type": "string" },
          "email": { "type": "string" },
          "displayName": { "type": "string", "maxLength": 100 },
          "emailVerified": { "type": "boolean" },
          "profilePicture": { "type": "string" },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation date of the [Account](#schema_account) in ISO 8601 format"
          }
        },
        "required": ["id", "email", "emailVerified", "createdAt"],
        "additionalProperties": false
      },
      "Usage": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Id of the usage that it is linked to. It can either be a workspace id or a bot id"
          },
          "period": { "type": "string", "description": "Period of the quota that it is applied to" },
          "value": { "type": "number", "description": "Value of the current usage" },
          "quota": { "type": "number", "description": "Quota of the current usage" },
          "type": {
            "type": "string",
            "enum": [
              "invocation_timeout",
              "invocation_calls",
              "storage_count",
              "bot_count",
              "knowledgebase_vector_storage",
              "workspace_ratelimit",
              "table_row_count",
              "workspace_member_count",
              "integrations_owned_count",
              "ai_spend",
              "openai_spend",
              "bing_search_spend",
              "always_alive"
            ],
            "description": "Usage type that can be used"
          }
        },
        "required": ["id", "period", "value", "quota", "type"],
        "additionalProperties": false
      },
      "Issue": {
        "type": "object",
        "properties": {
          "id": { "type": "string" },
          "code": { "type": "string" },
          "createdAt": { "type": "string", "format": "date-time" },
          "lastSeenAt": { "type": "string", "format": "date-time" },
          "title": { "type": "string" },
          "description": { "type": "string" },
          "groupedData": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "properties": { "raw": { "type": "string" }, "pretty": { "type": "string" } },
              "required": ["raw"],
              "additionalProperties": false
            }
          },
          "eventsCount": { "type": "number" },
          "category": { "type": "string", "enum": ["user_code", "limits", "configuration", "other"] },
          "resolutionLink": { "type": "string", "nullable": true }
        },
        "required": [
          "id",
          "code",
          "createdAt",
          "lastSeenAt",
          "title",
          "description",
          "groupedData",
          "eventsCount",
          "category",
          "resolutionLink"
        ],
        "additionalProperties": false
      },
      "IssueEvent": {
        "type": "object",
        "properties": {
          "id": { "type": "string" },
          "createdAt": { "type": "string", "format": "date-time" },
          "data": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "properties": { "raw": { "type": "string" }, "pretty": { "type": "string" } },
              "required": ["raw"],
              "additionalProperties": false
            }
          }
        },
        "required": ["id", "createdAt", "data"],
        "additionalProperties": false
      },
      "Activity": {
        "type": "object",
        "properties": {
          "id": { "type": "string" },
          "description": { "type": "string" },
          "taskId": { "type": "string" },
          "category": {
            "type": "string",
            "enum": [
              "unknown",
              "capture",
              "bot_message",
              "user_message",
              "agent_message",
              "event",
              "action",
              "task_status",
              "subtask_status",
              "exception"
            ]
          },
          "data": { "type": "object", "additionalProperties": true },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation date of the activity in ISO 8601 format"
          }
        },
        "required": ["id", "description", "taskId", "category", "data", "createdAt"],
        "additionalProperties": false
      },
      "Version": {
        "type": "object",
        "properties": { "id": { "type": "string" }, "name": { "type": "string" }, "description": { "type": "string" } },
        "required": ["id", "name"],
        "additionalProperties": false
      },
      "User": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "minLength": 28, "maxLength": 36, "description": "Id of the [User](#schema_user)" },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation date of the [User](#schema_user) in ISO 8601 format"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Updating date of the [User](#schema_user) in ISO 8601 format"
          },
          "tags": {
            "type": "object",
            "additionalProperties": { "type": "string" },
            "description": "Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them."
          },
          "name": { "type": "string", "maxLength": 200, "description": "Name of the [User](#schema_user)" },
          "pictureUrl": {
            "type": "string",
            "maxLength": 40000,
            "description": "Picture URL of the [User](#schema_user)"
          }
        },
        "required": ["id", "createdAt", "updatedAt", "tags"],
        "description": "The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.",
        "additionalProperties": false
      },
      "Conversation": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "Id of the [Conversation](#schema_conversation)"
          },
          "currentTaskId": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "Id of the current [Task](#schema_task)"
          },
          "currentWorkflowId": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "Id of the current [Workflow](#schema_workflow)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation date of the [Conversation](#schema_conversation) in ISO 8601 format"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Updating date of the [Conversation](#schema_conversation) in ISO 8601 format"
          },
          "channel": {
            "type": "string",
            "description": "Name of the channel where the [Conversation](#schema_conversation) is happening"
          },
          "integration": {
            "type": "string",
            "description": "Name of the integration that created the [Conversation](#schema_conversation)"
          },
          "tags": {
            "type": "object",
            "additionalProperties": { "type": "string" },
            "description": "Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them."
          }
        },
        "required": ["id", "createdAt", "updatedAt", "channel", "integration", "tags"],
        "description": "The [Conversation](#schema_conversation) object represents an exchange of messages between one or more users. A [Conversation](#schema_conversation) is always linked to an integration's channels. For example, a Slack channel represents a conversation.",
        "additionalProperties": false
      },
      "Event": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "Id of the [Event](#schema_event)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation date of the [Event](#schema_event) in ISO 8601 format"
          },
          "type": { "type": "string", "maxLength": 200, "description": "Type of the [Event](#schema_event)." },
          "payload": {
            "type": "object",
            "additionalProperties": true,
            "description": "Payload is the content of the event defined by the integration installed on your bot or one of the default events created by our api."
          },
          "conversationId": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "ID of the [Conversation](#schema_conversation) to link the event to."
          },
          "userId": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "ID of the [User](#schema_user) to link the event to."
          },
          "messageId": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "ID of the [Message](#schema_message) to link the event to."
          },
          "status": { "type": "string", "enum": ["pending", "processed", "ignored", "failed", "scheduled"] },
          "failureReason": {
            "type": "string",
            "maxLength": 2000,
            "nullable": true,
            "description": "Reason why the event failed to be processed"
          }
        },
        "required": ["id", "createdAt", "type", "payload", "status", "failureReason"],
        "description": "The event object represents an action or an occurrence.",
        "additionalProperties": false
      },
      "Message": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "Id of the [Message](#schema_message)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation date of the [Message](#schema_message) in ISO 8601 format"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Update date of the [Message](#schema_message) in ISO 8601 format"
          },
          "type": {
            "type": "string",
            "maxLength": 200,
            "description": "Type of the [Message](#schema_message) represents the resource type that the message is related to"
          },
          "payload": {
            "type": "object",
            "additionalProperties": true,
            "description": "Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location"
          },
          "direction": {
            "type": "string",
            "enum": ["incoming", "outgoing"],
            "description": "Direction of the message (`incoming` or `outgoing`)."
          },
          "userId": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "ID of the [User](#schema_user)"
          },
          "conversationId": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "ID of the [Conversation](#schema_conversation)"
          },
          "tags": {
            "type": "object",
            "additionalProperties": { "type": "string" },
            "description": "Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them."
          }
        },
        "required": [
          "id",
          "createdAt",
          "updatedAt",
          "type",
          "payload",
          "direction",
          "userId",
          "conversationId",
          "tags"
        ],
        "description": "The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user).",
        "additionalProperties": false
      },
      "State": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "Id of the [State](#schema_state)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation date of the [State](#schema_state) in ISO 8601 format"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Updating date of the [State](#schema_state) in ISO 8601 format"
          },
          "botId": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "Id of the [Bot](#schema_bot)"
          },
          "conversationId": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "Id of the [Conversation](#schema_conversation)"
          },
          "userId": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "Id of the [User](#schema_user)"
          },
          "name": {
            "type": "string",
            "maxLength": 200,
            "description": "Name of the [State](#schema_state) which is declared inside the bot definition"
          },
          "type": {
            "type": "string",
            "enum": ["conversation", "user", "bot", "task", "integration", "workflow"],
            "description": "Type of the [State](#schema_state) represents the resource type (`conversation`, `user`, `bot`, `task`, `integration` or `workflow`) that the state is related to"
          },
          "payload": {
            "type": "object",
            "additionalProperties": true,
            "description": "Payload is the content of the state defined by your bot."
          }
        },
        "required": ["id", "createdAt", "updatedAt", "botId", "name", "type", "payload"],
        "description": "The state object represents the current payload. A state is always linked to either a bot, a conversation or a user.",
        "additionalProperties": false
      },
      "Task": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "minLength": 28, "maxLength": 36, "description": "Id of the [Task](#schema_task)" },
          "title": { "type": "string", "maxLength": 64, "description": "Title describing the task" },
          "description": {
            "type": "string",
            "maxLength": 256,
            "description": "All the notes related to the execution of the current task"
          },
          "type": { "type": "string", "description": "Type of the task" },
          "data": { "type": "object", "additionalProperties": true, "description": "Content related to the task" },
          "status": {
            "type": "string",
            "enum": ["pending", "in_progress", "failed", "completed", "blocked", "paused", "timeout", "cancelled"],
            "description": "Status of the task"
          },
          "parentTaskId": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "Parent task id is the parent task that created this task"
          },
          "conversationId": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "Conversation id related to this task"
          },
          "userId": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "Specific user related to this task"
          },
          "timeoutAt": {
            "type": "string",
            "format": "date-time",
            "description": "The timeout date where the task should be failed in the ISO 8601 format"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation date of the task in ISO 8601 format"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Updating date of the task in ISO 8601 format"
          },
          "failureReason": {
            "type": "string",
            "maxLength": 2000,
            "description": "If the task fails this is the reason behind it"
          },
          "tags": {
            "type": "object",
            "additionalProperties": { "type": "string" },
            "description": "Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Task](#schema_task). Individual keys can be unset by posting an empty value to them."
          }
        },
        "required": [
          "id",
          "title",
          "description",
          "type",
          "data",
          "status",
          "timeoutAt",
          "createdAt",
          "updatedAt",
          "tags"
        ],
        "description": "Task definition",
        "additionalProperties": false
      },
      "Workflow": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "Id of the [Workflow](#schema_workflow)"
          },
          "name": { "type": "string", "maxLength": 200, "description": "Name of the workflow" },
          "status": {
            "type": "string",
            "enum": ["pending", "in_progress", "failed", "completed", "listening", "paused", "timedout", "cancelled"],
            "description": "Status of the [Workflow](#schema_workflow)"
          },
          "input": {
            "type": "object",
            "additionalProperties": true,
            "description": "Input provided to the [Workflow](#schema_workflow)"
          },
          "output": {
            "type": "object",
            "additionalProperties": true,
            "description": "Data returned by the [Workflow](#schema_workflow) output"
          },
          "parentWorkflowId": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "Parent [Workflow](#schema_workflow) id is the parent [Workflow](#schema_workflow) that created this [Workflow](#schema_workflow)"
          },
          "conversationId": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "Conversation id related to this [Workflow](#schema_workflow)"
          },
          "userId": {
            "type": "string",
            "minLength": 28,
            "maxLength": 36,
            "description": "User id related to this [Workflow](#schema_workflow)"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation date of the [Workflow](#schema_workflow) in ISO 8601 format"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Updating date of the [Workflow](#schema_workflow) in ISO 8601 format"
          },
          "completedAt": {
            "type": "string",
            "format": "date-time",
            "description": "The date when the [Workflow](#schema_workflow) completed in ISO 8601 format"
          },
          "failureReason": {
            "type": "string",
            "maxLength": 2000,
            "description": "If the [Workflow](#schema_workflow) fails this is the reason behind it"
          },
          "timeoutAt": {
            "type": "string",
            "format": "date-time",
            "description": "The timeout date when the [Workflow](#schema_workflow) will fail in the ISO 8601 format"
          },
          "tags": {
            "type": "object",
            "additionalProperties": { "type": "string" },
            "description": "Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Workflow](#schema_workflow). Individual keys can be unset by posting an empty value to them."
          }
        },
        "required": ["id", "name", "status", "input", "output", "createdAt", "updatedAt", "timeoutAt", "tags"],
        "description": "Workflow definition",
        "additionalProperties": false
      },
      "Table": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "description": "Unique identifier for the table" },
          "name": {
            "description": "Required. This name is used to identify your table.",
            "type": "string",
            "minLength": 1
          },
          "factor": {
            "default": 1,
            "type": "number",
            "minimum": 1,
            "maximum": 30,
            "description": "The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1."
          },
          "frozen": {
            "type": "boolean",
            "description": "A table designated as \"frozen\" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations."
          },
          "schema": {
            "type": "object",
            "properties": {
              "$schema": { "type": "string" },
              "properties": {
                "type": "object",
                "additionalProperties": {
                  "type": "object",
                  "properties": {
                    "type": { "type": "string", "enum": ["string", "number", "boolean", "object", "array", "null"] },
                    "format": { "type": "string", "enum": ["date-time"] },
                    "description": { "type": "string" },
                    "pattern": { "type": "string", "description": "String properties must match this pattern" },
                    "enum": {
                      "type": "array",
                      "items": { "type": "string" },
                      "description": "String properties must be one of these values"
                    },
                    "items": {
                      "type": "object",
                      "properties": {
                        "type": { "type": "string", "enum": ["string", "number", "boolean", "object", "array", "null"] }
                      },
                      "required": ["type"],
                      "additionalProperties": true,
                      "description": "Defines the shape of items in an array"
                    },
                    "nullable": { "default": true, "type": "boolean" },
                    "properties": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string",
                            "enum": ["string", "number", "boolean", "object", "array", "null"]
                          }
                        },
                        "required": ["type"],
                        "additionalProperties": true
                      }
                    },
                    "x-zui": {
                      "type": "object",
                      "properties": {
                        "index": { "type": "integer" },
                        "id": { "type": "string", "description": "[deprecated] ID of the column." },
                        "searchable": {
                          "type": "boolean",
                          "description": "Indicates if the column is vectorized and searchable."
                        },
                        "hidden": { "type": "boolean", "description": "Indicates if the field is hidden in the UI" },
                        "order": { "type": "number", "description": "Order of the column in the UI" },
                        "width": { "type": "number", "description": "Width of the column in the UI" },
                        "schemaId": { "type": "string", "description": "ID of the schema" },
                        "computed": {
                          "type": "object",
                          "properties": {
                            "action": { "type": "string", "enum": ["ai", "code", "workflow"] },
                            "dependencies": { "default": [], "type": "array", "items": { "type": "string" } },
                            "prompt": { "type": "string", "description": "Prompt when action is \"ai\"" },
                            "code": { "type": "string", "description": "Code to execute when action is \"code\"" },
                            "model": {
                              "default": "gpt-4o",
                              "type": "string",
                              "maxLength": 80,
                              "description": "Model to use when action is \"ai\""
                            },
                            "workflowId": {
                              "type": "string",
                              "maxLength": 20,
                              "description": "ID of Workflow to execute when action is \"workflow\""
                            },
                            "enabled": { "type": "boolean" }
                          },
                          "required": ["action"],
                          "additionalProperties": false
                        },
                        "typings": {
                          "type": "string",
                          "description": "TypeScript typings for the column. Recommended if the type is \"object\", ex: \"\\{ foo: string; bar: number \\}\""
                        }
                      },
                      "required": ["index"],
                      "additionalProperties": false
                    }
                  },
                  "required": ["type", "x-zui"],
                  "additionalProperties": false
                },
                "description": "List of keys/columns in the table."
              },
              "additionalProperties": {
                "type": "boolean",
                "enum": [true],
                "description": "Additional properties can be provided, but they will be ignored if no column matches."
              },
              "required": {
                "type": "array",
                "items": { "type": "string" },
                "description": "Array of required properties."
              },
              "type": { "type": "string", "enum": ["object"] }
            },
            "required": ["properties", "additionalProperties", "type"],
            "additionalProperties": false
          },
          "tags": {
            "type": "object",
            "additionalProperties": { "type": "string" },
            "description": "Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs."
          },
          "isComputeEnabled": {
            "type": "boolean",
            "description": "Indicates if the table is enabled for computation."
          },
          "createdAt": { "type": "string", "format": "date-time", "description": "Timestamp of table creation." },
          "updatedAt": { "type": "string", "format": "date-time", "description": "Timestamp of the last table update." }
        },
        "required": ["id", "name", "schema"],
        "additionalProperties": false
      },
      "Column": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "description": "Unique identifier for the column." },
          "name": {
            "type": "string",
            "minLength": 1,
            "maxLength": 30,
            "description": "Name of the column, must be within length limits."
          },
          "description": { "type": "string", "description": "Optional descriptive text about the column." },
          "searchable": { "type": "boolean", "description": "Indicates if the column is vectorized and searchable." },
          "type": {
            "type": "string",
            "enum": ["string", "number", "boolean", "date", "object"],
            "description": "Specifies the data type of the column. Use \"object\" for complex data structures."
          },
          "typings": {
            "type": "string",
            "description": "TypeScript typings for the column. Recommended if the type is \"object\", ex: \"\\{ foo: string; bar: number \\}\""
          },
          "computed": {
            "type": "object",
            "properties": {
              "action": { "type": "string", "enum": ["ai", "code", "workflow"] },
              "dependencies": { "default": [], "type": "array", "items": { "type": "string" } },
              "prompt": { "type": "string", "description": "Prompt when action is \"ai\"" },
              "code": { "type": "string", "description": "Code to execute when action is \"code\"" },
              "model": {
                "default": "gpt-4o",
                "type": "string",
                "maxLength": 80,
                "description": "Model to use when action is \"ai\""
              },
              "workflowId": {
                "type": "string",
                "maxLength": 20,
                "description": "ID of Workflow to execute when action is \"workflow\""
              },
              "enabled": { "type": "boolean" }
            },
            "required": ["action"],
            "additionalProperties": false
          },
          "schema": { "type": "object", "additionalProperties": true }
        },
        "required": ["name", "type"],
        "additionalProperties": false
      },
      "Row": {
        "type": "object",
        "properties": {
          "id": { "type": "number", "description": "Unique identifier for the row." },
          "createdAt": { "type": "string", "format": "date-time", "description": "Timestamp of row creation." },
          "updatedAt": { "type": "string", "format": "date-time", "description": "Timestamp of the last row update." },
          "computed": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "status": { "type": "string" },
                "error": { "type": "string" },
                "updatedBy": { "type": "string" },
                "updatedAt": { "type": "string" }
              },
              "required": ["status"],
              "additionalProperties": false
            }
          },
          "stale": {
            "type": "array",
            "items": { "type": "string" },
            "description": "[Read-only] List of stale values that are waiting to be recomputed."
          },
          "similarity": {
            "type": "number",
            "description": "Optional numeric value indicating similarity, when using findTableRows."
          }
        },
        "required": ["id", "computed"],
        "additionalProperties": true
      },
      "File": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "description": "File ID" },
          "botId": { "type": "string", "description": "The ID of the bot the file belongs to" },
          "key": {
            "type": "string",
            "description": "Unique key for the file. Must be unique across the bot (and the integration, when applicable)."
          },
          "url": {
            "type": "string",
            "description": "URL to retrieve the file content. This URL will be ready to use once the file is uploaded.\n\nIf the file has a `public_content` policy, this will contain the permanent public URL to retrieve the file, otherwise this will contain a temporary pre-signed URL to download the file which should be used shortly after retrieving and should not be stored long-term as the URL will expire after a short timeframe."
          },
          "size": {
            "type": "number",
            "description": "File size in bytes. Non-null if file upload status is \"COMPLETE\".",
            "nullable": true
          },
          "contentType": { "type": "string", "description": "MIME type of the file's content" },
          "tags": {
            "type": "object",
            "additionalProperties": { "type": "string", "maxLength": 1000 },
            "description": "The tags of the file as an object of key/value pairs"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": { "nullable": true },
            "description": "Metadata of the file as an object of key/value pairs. The values can be of any type."
          },
          "createdAt": { "type": "string", "description": "File creation timestamp in ISO 8601 format" },
          "updatedAt": { "type": "string", "description": "File last update timestamp in ISO 8601 format" },
          "accessPolicies": {
            "type": "array",
            "items": { "type": "string", "enum": ["integrations", "public_content"] },
            "description": "Access policies configured for the file."
          },
          "index": {
            "type": "boolean",
            "description": "Whether the file was requested to be indexed for search or not."
          },
          "status": {
            "type": "string",
            "enum": [
              "upload_pending",
              "upload_failed",
              "upload_completed",
              "indexing_pending",
              "indexing_failed",
              "indexing_completed"
            ],
            "description": "Status of the file. If the status is `upload_pending`, the file content has not been uploaded yet. The status will be set to `upload_completed` once the file content has been uploaded successfully.\n\nIf the upload failed for any reason (e.g. exceeding the storage quota or the maximum file size limit) the status will be set to `upload_failed` and the reason for the failure will be available in the `failedStatusReason` field of the file.\n\nHowever, if the file has been uploaded and the `index` attribute was set to `true` on the file, the status will immediately transition to the `indexing_pending` status (the `upload_completed` status step will be skipped).\n\nOnce the indexing is completed and the file is ready to be used for searching its status will be set to `indexing_completed`. If the indexing failed the status will be set to `indexing_failed` and the reason for the failure will be available in the `failedStatusReason` field."
          },
          "failedStatusReason": {
            "type": "string",
            "description": "If the file status is `upload_failed` or `indexing_failed` this will contain the reason of the failure."
          },
          "expiresAt": { "type": "string", "description": "File expiry timestamp in ISO 8601 format" }
        },
        "required": [
          "id",
          "botId",
          "key",
          "url",
          "size",
          "contentType",
          "tags",
          "metadata",
          "createdAt",
          "updatedAt",
          "accessPolicies",
          "index",
          "status"
        ],
        "additionalProperties": false
      }
    },
    "responses": {
      "upsertFileResponse": {
        "description": "The created or updated file",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "file": {
                  "type": "object",
                  "properties": {
                    "id": { "type": "string", "description": "File ID" },
                    "botId": { "type": "string", "description": "The ID of the bot the file belongs to" },
                    "key": {
                      "type": "string",
                      "description": "Unique key for the file. Must be unique across the bot (and the integration, when applicable)."
                    },
                    "url": {
                      "type": "string",
                      "description": "URL to retrieve the file content. This URL will be ready to use once the file is uploaded.\n\nIf the file has a `public_content` policy, this will contain the permanent public URL to retrieve the file, otherwise this will contain a temporary pre-signed URL to download the file which should be used shortly after retrieving and should not be stored long-term as the URL will expire after a short timeframe."
                    },
                    "size": {
                      "type": "number",
                      "description": "File size in bytes. Non-null if file upload status is \"COMPLETE\".",
                      "nullable": true
                    },
                    "contentType": { "type": "string", "description": "MIME type of the file's content" },
                    "tags": {
                      "type": "object",
                      "additionalProperties": { "type": "string", "maxLength": 1000 },
                      "description": "The tags of the file as an object of key/value pairs"
                    },
                    "metadata": {
                      "type": "object",
                      "additionalProperties": { "nullable": true },
                      "description": "Metadata of the file as an object of key/value pairs. The values can be of any type."
                    },
                    "createdAt": { "type": "string", "description": "File creation timestamp in ISO 8601 format" },
                    "updatedAt": { "type": "string", "description": "File last update timestamp in ISO 8601 format" },
                    "accessPolicies": {
                      "type": "array",
                      "items": { "type": "string", "enum": ["integrations", "public_content"] },
                      "description": "Access policies configured for the file."
                    },
                    "index": {
                      "type": "boolean",
                      "description": "Whether the file was requested to be indexed for search or not."
                    },
                    "status": {
                      "type": "string",
                      "enum": [
                        "upload_pending",
                        "upload_failed",
                        "upload_completed",
                        "indexing_pending",
                        "indexing_failed",
                        "indexing_completed"
                      ],
                      "description": "Status of the file. If the status is `upload_pending`, the file content has not been uploaded yet. The status will be set to `upload_completed` once the file content has been uploaded successfully.\n\nIf the upload failed for any reason (e.g. exceeding the storage quota or the maximum file size limit) the status will be set to `upload_failed` and the reason for the failure will be available in the `failedStatusReason` field of the file.\n\nHowever, if the file has been uploaded and the `index` attribute was set to `true` on the file, the status will immediately transition to the `indexing_pending` status (the `upload_completed` status step will be skipped).\n\nOnce the indexing is completed and the file is ready to be used for searching its status will be set to `indexing_completed`. If the indexing failed the status will be set to `indexing_failed` and the reason for the failure will be available in the `failedStatusReason` field."
                    },
                    "failedStatusReason": {
                      "type": "string",
                      "description": "If the file status is `upload_failed` or `indexing_failed` this will contain the reason of the failure."
                    },
                    "expiresAt": { "type": "string", "description": "File expiry timestamp in ISO 8601 format" },
                    "uploadUrl": {
                      "type": "string",
                      "description": "URL to upload the file content. File content needs to be sent to this URL via a PUT request."
                    }
                  },
                  "required": [
                    "id",
                    "botId",
                    "key",
                    "url",
                    "size",
                    "contentType",
                    "tags",
                    "metadata",
                    "createdAt",
                    "updatedAt",
                    "accessPolicies",
                    "index",
                    "status",
                    "uploadUrl"
                  ],
                  "additionalProperties": false
                }
              },
              "required": ["file"],
              "title": "upsertFileResponse",
              "additionalProperties": false
            }
          }
        }
      },
      "deleteFileResponse": {
        "description": "Empty response.",
        "content": {
          "application/json": {
            "schema": { "type": "object", "title": "deleteFileResponse", "additionalProperties": false }
          }
        }
      },
      "listFilesResponse": {
        "description": "Returns the list of files related to the bot.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "files": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "id": { "type": "string", "description": "File ID" },
                      "botId": { "type": "string", "description": "The ID of the bot the file belongs to" },
                      "key": {
                        "type": "string",
                        "description": "Unique key for the file. Must be unique across the bot (and the integration, when applicable)."
                      },
                      "url": {
                        "type": "string",
                        "description": "URL to retrieve the file content. This URL will be ready to use once the file is uploaded.\n\nIf the file has a `public_content` policy, this will contain the permanent public URL to retrieve the file, otherwise this will contain a temporary pre-signed URL to download the file which should be used shortly after retrieving and should not be stored long-term as the URL will expire after a short timeframe."
                      },
                      "size": {
                        "type": "number",
                        "description": "File size in bytes. Non-null if file upload status is \"COMPLETE\".",
                        "nullable": true
                      },
                      "contentType": { "type": "string", "description": "MIME type of the file's content" },
                      "tags": {
                        "type": "object",
                        "additionalProperties": { "type": "string", "maxLength": 1000 },
                        "description": "The tags of the file as an object of key/value pairs"
                      },
                      "metadata": {
                        "type": "object",
                        "additionalProperties": { "nullable": true },
                        "description": "Metadata of the file as an object of key/value pairs. The values can be of any type."
                      },
                      "createdAt": { "type": "string", "description": "File creation timestamp in ISO 8601 format" },
                      "updatedAt": { "type": "string", "description": "File last update timestamp in ISO 8601 format" },
                      "accessPolicies": {
                        "type": "array",
                        "items": { "type": "string", "enum": ["integrations", "public_content"] },
                        "description": "Access policies configured for the file."
                      },
                      "index": {
                        "type": "boolean",
                        "description": "Whether the file was requested to be indexed for search or not."
                      },
                      "status": {
                        "type": "string",
                        "enum": [
                          "upload_pending",
                          "upload_failed",
                          "upload_completed",
                          "indexing_pending",
                          "indexing_failed",
                          "indexing_completed"
                        ],
                        "description": "Status of the file. If the status is `upload_pending`, the file content has not been uploaded yet. The status will be set to `upload_completed` once the file content has been uploaded successfully.\n\nIf the upload failed for any reason (e.g. exceeding the storage quota or the maximum file size limit) the status will be set to `upload_failed` and the reason for the failure will be available in the `failedStatusReason` field of the file.\n\nHowever, if the file has been uploaded and the `index` attribute was set to `true` on the file, the status will immediately transition to the `indexing_pending` status (the `upload_completed` status step will be skipped).\n\nOnce the indexing is completed and the file is ready to be used for searching its status will be set to `indexing_completed`. If the indexing failed the status will be set to `indexing_failed` and the reason for the failure will be available in the `failedStatusReason` field."
                      },
                      "failedStatusReason": {
                        "type": "string",
                        "description": "If the file status is `upload_failed` or `indexing_failed` this will contain the reason of the failure."
                      },
                      "expiresAt": { "type": "string", "description": "File expiry timestamp in ISO 8601 format" }
                    },
                    "required": [
                      "id",
                      "botId",
                      "key",
                      "url",
                      "size",
                      "contentType",
                      "tags",
                      "metadata",
                      "createdAt",
                      "updatedAt",
                      "accessPolicies",
                      "index",
                      "status"
                    ]
                  }
                },
                "meta": {
                  "type": "object",
                  "properties": {
                    "nextToken": {
                      "type": "string",
                      "description": "The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint."
                    }
                  },
                  "additionalProperties": false
                }
              },
              "required": ["files", "meta"],
              "title": "listFilesResponse",
              "additionalProperties": false
            }
          }
        }
      },
      "getFileResponse": {
        "description": "An object containing the file metadata and URL",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "file": {
                  "type": "object",
                  "properties": {
                    "id": { "type": "string", "description": "File ID" },
                    "botId": { "type": "string", "description": "The ID of the bot the file belongs to" },
                    "key": {
                      "type": "string",
                      "description": "Unique key for the file. Must be unique across the bot (and the integration, when applicable)."
                    },
                    "url": {
                      "type": "string",
                      "description": "URL to retrieve the file content. This URL will be ready to use once the file is uploaded.\n\nIf the file has a `public_content` policy, this will contain the permanent public URL to retrieve the file, otherwise this will contain a temporary pre-signed URL to download the file which should be used shortly after retrieving and should not be stored long-term as the URL will expire after a short timeframe."
                    },
                    "size": {
                      "type": "number",
                      "description": "File size in bytes. Non-null if file upload status is \"COMPLETE\".",
                      "nullable": true
                    },
                    "contentType": { "type": "string", "description": "MIME type of the file's content" },
                    "tags": {
                      "type": "object",
                      "additionalProperties": { "type": "string", "maxLength": 1000 },
                      "description": "The tags of the file as an object of key/value pairs"
                    },
                    "metadata": {
                      "type": "object",
                      "additionalProperties": { "nullable": true },
                      "description": "Metadata of the file as an object of key/value pairs. The values can be of any type."
                    },
                    "createdAt": { "type": "string", "description": "File creation timestamp in ISO 8601 format" },
                    "updatedAt": { "type": "string", "description": "File last update timestamp in ISO 8601 format" },
                    "accessPolicies": {
                      "type": "array",
                      "items": { "type": "string", "enum": ["integrations", "public_content"] },
                      "description": "Access policies configured for the file."
                    },
                    "index": {
                      "type": "boolean",
                      "description": "Whether the file was requested to be indexed for search or not."
                    },
                    "status": {
                      "type": "string",
                      "enum": [
                        "upload_pending",
                        "upload_failed",
                        "upload_completed",
                        "indexing_pending",
                        "indexing_failed",
                        "indexing_completed"
                      ],
                      "description": "Status of the file. If the status is `upload_pending`, the file content has not been uploaded yet. The status will be set to `upload_completed` once the file content has been uploaded successfully.\n\nIf the upload failed for any reason (e.g. exceeding the storage quota or the maximum file size limit) the status will be set to `upload_failed` and the reason for the failure will be available in the `failedStatusReason` field of the file.\n\nHowever, if the file has been uploaded and the `index` attribute was set to `true` on the file, the status will immediately transition to the `indexing_pending` status (the `upload_completed` status step will be skipped).\n\nOnce the indexing is completed and the file is ready to be used for searching its status will be set to `indexing_completed`. If the indexing failed the status will be set to `indexing_failed` and the reason for the failure will be available in the `failedStatusReason` field."
                    },
                    "failedStatusReason": {
                      "type": "string",
                      "description": "If the file status is `upload_failed` or `indexing_failed` this will contain the reason of the failure."
                    },
                    "expiresAt": { "type": "string", "description": "File expiry timestamp in ISO 8601 format" }
                  },
                  "required": [
                    "id",
                    "botId",
                    "key",
                    "url",
                    "size",
                    "contentType",
                    "tags",
                    "metadata",
                    "createdAt",
                    "updatedAt",
                    "accessPolicies",
                    "index",
                    "status"
                  ],
                  "additionalProperties": false
                }
              },
              "required": ["file"],
              "title": "getFileResponse",
              "additionalProperties": false
            }
          }
        }
      },
      "updateFileMetadataResponse": {
        "description": "An object containing the updated file metadata.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "file": {
                  "type": "object",
                  "properties": {
                    "id": { "type": "string", "description": "File ID" },
                    "botId": { "type": "string", "description": "The ID of the bot the file belongs to" },
                    "key": {
                      "type": "string",
                      "description": "Unique key for the file. Must be unique across the bot (and the integration, when applicable)."
                    },
                    "url": {
                      "type": "string",
                      "description": "URL to retrieve the file content. This URL will be ready to use once the file is uploaded.\n\nIf the file has a `public_content` policy, this will contain the permanent public URL to retrieve the file, otherwise this will contain a temporary pre-signed URL to download the file which should be used shortly after retrieving and should not be stored long-term as the URL will expire after a short timeframe."
                    },
                    "size": {
                      "type": "number",
                      "description": "File size in bytes. Non-null if file upload status is \"COMPLETE\".",
                      "nullable": true
                    },
                    "contentType": { "type": "string", "description": "MIME type of the file's content" },
                    "tags": {
                      "type": "object",
                      "additionalProperties": { "type": "string", "maxLength": 1000 },
                      "description": "The tags of the file as an object of key/value pairs"
                    },
                    "metadata": {
                      "type": "object",
                      "additionalProperties": { "nullable": true },
                      "description": "Metadata of the file as an object of key/value pairs. The values can be of any type."
                    },
                    "createdAt": { "type": "string", "description": "File creation timestamp in ISO 8601 format" },
                    "updatedAt": { "type": "string", "description": "File last update timestamp in ISO 8601 format" },
                    "accessPolicies": {
                      "type": "array",
                      "items": { "type": "string", "enum": ["integrations", "public_content"] },
                      "description": "Access policies configured for the file."
                    },
                    "index": {
                      "type": "boolean",
                      "description": "Whether the file was requested to be indexed for search or not."
                    },
                    "status": {
                      "type": "string",
                      "enum": [
                        "upload_pending",
                        "upload_failed",
                        "upload_completed",
                        "indexing_pending",
                        "indexing_failed",
                        "indexing_completed"
                      ],
                      "description": "Status of the file. If the status is `upload_pending`, the file content has not been uploaded yet. The status will be set to `upload_completed` once the file content has been uploaded successfully.\n\nIf the upload failed for any reason (e.g. exceeding the storage quota or the maximum file size limit) the status will be set to `upload_failed` and the reason for the failure will be available in the `failedStatusReason` field of the file.\n\nHowever, if the file has been uploaded and the `index` attribute was set to `true` on the file, the status will immediately transition to the `indexing_pending` status (the `upload_completed` status step will be skipped).\n\nOnce the indexing is completed and the file is ready to be used for searching its status will be set to `indexing_completed`. If the indexing failed the status will be set to `indexing_failed` and the reason for the failure will be available in the `failedStatusReason` field."
                    },
                    "failedStatusReason": {
                      "type": "string",
                      "description": "If the file status is `upload_failed` or `indexing_failed` this will contain the reason of the failure."
                    },
                    "expiresAt": { "type": "string", "description": "File expiry timestamp in ISO 8601 format" }
                  },
                  "required": [
                    "id",
                    "botId",
                    "key",
                    "url",
                    "size",
                    "contentType",
                    "tags",
                    "metadata",
                    "createdAt",
                    "updatedAt",
                    "accessPolicies",
                    "index",
                    "status"
                  ],
                  "additionalProperties": false
                }
              },
              "required": ["file"],
              "title": "updateFileMetadataResponse",
              "additionalProperties": false
            }
          }
        }
      },
      "copyFileResponse": {
        "description": "An object containing the file metadata and URL",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "file": {
                  "type": "object",
                  "properties": {
                    "id": { "type": "string", "description": "File ID" },
                    "botId": { "type": "string", "description": "The ID of the bot the file belongs to" },
                    "key": {
                      "type": "string",
                      "description": "Unique key for the file. Must be unique across the bot (and the integration, when applicable)."
                    },
                    "url": {
                      "type": "string",
                      "description": "URL to retrieve the file content. This URL will be ready to use once the file is uploaded.\n\nIf the file has a `public_content` policy, this will contain the permanent public URL to retrieve the file, otherwise this will contain a temporary pre-signed URL to download the file which should be used shortly after retrieving and should not be stored long-term as the URL will expire after a short timeframe."
                    },
                    "size": {
                      "type": "number",
                      "description": "File size in bytes. Non-null if file upload status is \"COMPLETE\".",
                      "nullable": true
                    },
                    "contentType": { "type": "string", "description": "MIME type of the file's content" },
                    "tags": {
                      "type": "object",
                      "additionalProperties": { "type": "string", "maxLength": 1000 },
                      "description": "The tags of the file as an object of key/value pairs"
                    },
                    "metadata": {
                      "type": "object",
                      "additionalProperties": { "nullable": true },
                      "description": "Metadata of the file as an object of key/value pairs. The values can be of any type."
                    },
                    "createdAt": { "type": "string", "description": "File creation timestamp in ISO 8601 format" },
                    "updatedAt": { "type": "string", "description": "File last update timestamp in ISO 8601 format" },
                    "accessPolicies": {
                      "type": "array",
                      "items": { "type": "string", "enum": ["integrations", "public_content"] },
                      "description": "Access policies configured for the file."
                    },
                    "index": {
                      "type": "boolean",
                      "description": "Whether the file was requested to be indexed for search or not."
                    },
                    "status": {
                      "type": "string",
                      "enum": [
                        "upload_pending",
                        "upload_failed",
                        "upload_completed",
                        "indexing_pending",
                        "indexing_failed",
                        "indexing_completed"
                      ],
                      "description": "Status of the file. If the status is `upload_pending`, the file content has not been uploaded yet. The status will be set to `upload_completed` once the file content has been uploaded successfully.\n\nIf the upload failed for any reason (e.g. exceeding the storage quota or the maximum file size limit) the status will be set to `upload_failed` and the reason for the failure will be available in the `failedStatusReason` field of the file.\n\nHowever, if the file has been uploaded and the `index` attribute was set to `true` on the file, the status will immediately transition to the `indexing_pending` status (the `upload_completed` status step will be skipped).\n\nOnce the indexing is completed and the file is ready to be used for searching its status will be set to `indexing_completed`. If the indexing failed the status will be set to `indexing_failed` and the reason for the failure will be available in the `failedStatusReason` field."
                    },
                    "failedStatusReason": {
                      "type": "string",
                      "description": "If the file status is `upload_failed` or `indexing_failed` this will contain the reason of the failure."
                    },
                    "expiresAt": { "type": "string", "description": "File expiry timestamp in ISO 8601 format" }
                  },
                  "required": [
                    "id",
                    "botId",
                    "key",
                    "url",
                    "size",
                    "contentType",
                    "tags",
                    "metadata",
                    "createdAt",
                    "updatedAt",
                    "accessPolicies",
                    "index",
                    "status"
                  ],
                  "additionalProperties": false
                }
              },
              "required": ["file"],
              "title": "copyFileResponse",
              "additionalProperties": false
            }
          }
        }
      },
      "searchFilesResponse": {
        "description": "Returns the text passages within all indexed files that matched the query.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "passages": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "content": {
                        "type": "string",
                        "description": "The content of the matching passage in the file including surrounding context, if any."
                      },
                      "score": {
                        "type": "number",
                        "description": "The score indicating the similarity of the passage to the query. A higher score indicates higher similarity."
                      },
                      "meta": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string",
                            "enum": ["chunk", "summary", "consolidated", "image"],
                            "description": "The type of passage"
                          },
                          "subtype": {
                            "type": "string",
                            "enum": [
                              "title",
                              "subtitle",
                              "paragraph",
                              "blockquote",
                              "list",
                              "table",
                              "code",
                              "image",
                              "page"
                            ],
                            "description": "The subtype of passage, if available."
                          },
                          "pageNumber": {
                            "type": "integer",
                            "description": "Page number the passage is located on. Only applicable if the passage was extracted from a PDF file."
                          },
                          "position": {
                            "type": "integer",
                            "description": "Position number of the passage in the file relative to the other passages, if available. Can be used to know the order of passages within a file."
                          },
                          "sourceUrl": {
                            "type": "string",
                            "format": "uri",
                            "description": "The URL of the source file for the vector, if applicable (e.g. for image vectors)."
                          }
                        },
                        "description": "The passage metadata."
                      },
                      "file": {
                        "type": "object",
                        "properties": {
                          "id": { "type": "string", "description": "File ID" },
                          "key": {
                            "type": "string",
                            "description": "Unique key for the file. Must be unique across the bot (and the integration, when applicable)."
                          },
                          "contentType": { "type": "string", "description": "MIME type of the file's content" },
                          "tags": {
                            "type": "object",
                            "additionalProperties": { "type": "string", "maxLength": 1000 },
                            "description": "The tags of the file as an object of key-value pairs."
                          },
                          "createdAt": {
                            "type": "string",
                            "description": "File creation timestamp in ISO 8601 format"
                          },
                          "updatedAt": {
                            "type": "string",
                            "description": "File last update timestamp in ISO 8601 format"
                          }
                        },
                        "required": ["id", "key", "contentType", "tags", "createdAt", "updatedAt"]
                      }
                    },
                    "required": ["content", "score", "meta", "file"]
                  }
                }
              },
              "required": ["passages"],
              "title": "searchFilesResponse",
              "additionalProperties": false
            }
          }
        }
      },
      "listFilePassagesResponse": {
        "description": "Returns the list of passages extracted from a file.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "passages": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "id": { "type": "string", "description": "Passage ID" },
                      "content": { "type": "string", "description": "The content of the passage." },
                      "meta": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string",
                            "enum": ["chunk", "summary", "consolidated", "image"],
                            "description": "The type of passage"
                          },
                          "subtype": {
                            "type": "string",
                            "enum": [
                              "title",
                              "subtitle",
                              "paragraph",
                              "blockquote",
                              "list",
                              "table",
                              "code",
                              "image",
                              "page"
                            ],
                            "description": "The subtype of passage, if available."
                          },
                          "pageNumber": {
                            "type": "integer",
                            "description": "Page number the passage is located on. Only applicable if the passage was extracted from a PDF file."
                          },
                          "position": {
                            "type": "integer",
                            "description": "Position number of the passage in the file relative to the other passages, if available. Can be used to know the order of passages within a file."
                          },
                          "sourceUrl": {
                            "type": "string",
                            "format": "uri",
                            "description": "The URL of the source file for the vector, if applicable (e.g. for image vectors)."
                          }
                        },
                        "description": "The passage metadata."
                      }
                    },
                    "required": ["id", "content", "meta"]
                  }
                },
                "meta": {
                  "type": "object",
                  "properties": {
                    "nextToken": {
                      "type": "string",
                      "description": "The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint."
                    }
                  },
                  "additionalProperties": false
                }
              },
              "required": ["passages", "meta"],
              "title": "listFilePassagesResponse",
              "additionalProperties": false
            }
          }
        }
      },
      "listFileTagsResponse": {
        "description": "Returns the list of available tags used across all files of the bot.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "tags": { "type": "array", "items": { "type": "string" } },
                "meta": {
                  "type": "object",
                  "properties": {
                    "nextToken": {
                      "type": "string",
                      "description": "The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint."
                    }
                  },
                  "additionalProperties": false
                }
              },
              "required": ["tags", "meta"],
              "title": "listFileTagsResponse",
              "additionalProperties": false
            }
          }
        }
      },
      "listFileTagValuesResponse": {
        "description": "Returns the list of available values used for a given tag across all files of the bot.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "values": { "type": "array", "items": { "type": "string" } },
                "meta": {
                  "type": "object",
                  "properties": {
                    "nextToken": {
                      "type": "string",
                      "description": "The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint."
                    }
                  },
                  "additionalProperties": false
                }
              },
              "required": ["values", "meta"],
              "title": "listFileTagValuesResponse",
              "additionalProperties": false
            }
          }
        }
      },
      "createKnowledgeBaseResponse": {
        "description": "The created knowledge base",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "knowledgeBase": {
                  "type": "object",
                  "properties": {
                    "id": { "type": "string", "description": "Knowledge base ID" },
                    "name": { "type": "string", "description": "Name of the knowledge base." }
                  },
                  "required": ["id", "name"],
                  "additionalProperties": false
                }
              },
              "required": ["knowledgeBase"],
              "title": "createKnowledgeBaseResponse",
              "additionalProperties": false
            }
          }
        }
      },
      "deleteKnowledgeBaseResponse": {
        "description": "Empty response.",
        "content": {
          "application/json": {
            "schema": { "type": "object", "title": "deleteKnowledgeBaseResponse", "additionalProperties": false }
          }
        }
      },
      "updateKnowledgeBaseResponse": {
        "description": "The updated knowledge base",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "knowledgeBase": {
                  "type": "object",
                  "properties": {
                    "id": { "type": "string", "description": "Knowledge base ID" },
                    "name": { "type": "string", "description": "Name of the knowledge base." }
                  },
                  "required": ["id", "name"],
                  "additionalProperties": false
                }
              },
              "required": ["knowledgeBase"],
              "title": "updateKnowledgeBaseResponse",
              "additionalProperties": false
            }
          }
        }
      },
      "listKnowledgeBasesResponse": {
        "description": "Returns the list of knowledge bases for the bot.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "knowledgeBases": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "id": { "type": "string", "description": "Knowledge base ID" },
                      "name": { "type": "string", "description": "Name of the knowledge base." },
                      "createdAt": {
                        "type": "string",
                        "description": "Knowledge base creation timestamp in ISO 8601 format"
                      }
                    },
                    "required": ["id", "name", "createdAt"]
                  }
                },
                "meta": {
                  "type": "object",
                  "properties": {
                    "nextToken": {
                      "type": "string",
                      "description": "The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint."
                    }
                  },
                  "additionalProperties": false
                }
              },
              "required": ["knowledgeBases", "meta"],
              "title": "listKnowledgeBasesResponse",
              "additionalProperties": false
            }
          }
        }
      }
    },
    "requestBodies": {
      "upsertFileBody": {
        "description": "Properties of the file to create or update.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "key": {
                  "type": "string",
                  "description": "Unique key for the file. Must be unique across the bot (and the integration, when applicable)."
                },
                "tags": {
                  "type": "object",
                  "additionalProperties": { "type": "string", "maxLength": 1000 },
                  "description": "File tags as an object of key-value pairs. Tag values should be of `string` (text) type."
                },
                "size": {
                  "type": "number",
                  "description": "File size in bytes. This will count against your File Storage quota. If the `index` parameter is set to `true`, this will also count against your Vector DB Storage quota."
                },
                "index": {
                  "default": false,
                  "type": "boolean",
                  "description": "Set to a value of 'true' to index the file in vector storage. Only certain file formats are currently supported for indexing. Note that if a file is indexed, it will count towards both the Vector DB Storage quota and the File Storage quota of the workspace."
                },
                "indexing": {
                  "type": "object",
                  "properties": {
                    "configuration": {
                      "type": "object",
                      "properties": {
                        "parsing": {
                          "type": "object",
                          "properties": {
                            "minimumParagraphLength": {
                              "type": "integer",
                              "minimum": 50,
                              "maximum": 2000,
                              "description": "The minimum length a standalone paragraph should have. If a paragraph is shorter than this, it will be merged with the next immediate paragraph."
                            },
                            "smartCleanup": {
                              "type": "boolean",
                              "description": "(Team/Enterprise plan only, charged as AI Spend) Enabling this will use a lightweight/inexpensive LLM to clean up the extracted content of PDF files before indexing them to increase the quality of the stored vectors, as PDFs often store raw text in unusual ways which when extracted may result in formatting issues (e.g. broken sentences/paragraphs, unexpected headings, garbled characters, etc.) that can affect retrieval performance for certain user queries if left untouched.\n\nNotes:\n- This feature is only available in Team and Enterprise plans.\n- This feature is only available for PDF files. If the file isn't a PDF, this setting will be ignored and no AI Spend will be incurred.\n- We recommend using this feature for PDFs that have custom layouts or design. For simple text-based PDFs like documents and books, this feature is usually not necessary.\n- The smart cleanup takes some time to perform due to the LLM calls involved, so enabling it will increase the total time it takes to index the file.\n- We take steps to prevent the original text from being fundamentally changed but due to the nature of LLMs this could theoretically still happen so it's recommended to review the passages generated for the file after indexing to ensure the content is still accurate.\n- This feature is limited to the first 30 pages or 20 KB of text in the PDF file (whichever comes first). If the file has more content than these limits then the rest of the file will be indexed as-is without any cleanup. If you need to clean up the content of the entire file, consider splitting it into smaller files."
                            }
                          },
                          "additionalProperties": false
                        },
                        "chunking": {
                          "type": "object",
                          "properties": {
                            "maximumChunkLength": {
                              "type": "integer",
                              "minimum": 100,
                              "maximum": 5000,
                              "description": "The maximum length of a chunk in characters."
                            },
                            "embeddedContextLevels": {
                              "type": "integer",
                              "minimum": 0,
                              "maximum": 3,
                              "description": "The number of surrounding context levels to include in the vector embedding of the chunk."
                            },
                            "embedBreadcrumb": {
                              "type": "boolean",
                              "description": "Include the breadcrumb of the chunk in the vector embedding."
                            }
                          },
                          "additionalProperties": false
                        },
                        "summarization": {
                          "type": "object",
                          "properties": {
                            "enable": {
                              "default": false,
                              "type": "boolean",
                              "description": "(Team/Enterprise plan only, charged as AI Spend) Create summaries for this file and index them as standalone vectors. Enabling this option will incur in AI Spend cost (charged to the workspace of the bot) to generate the summaries based on the amount of content in the file and the summarization model used.\n\nPlease note that this feature is only available in Team and Enterprise plans."
                            },
                            "modelType": {
                              "default": "balanced",
                              "type": "string",
                              "enum": ["inexpensive", "balanced", "accurate"],
                              "description": "The model type to use for summarization."
                            },
                            "minimumInputLength": {
                              "type": "integer",
                              "minimum": 1000,
                              "maximum": 10000,
                              "description": "The minimum length a section of the file should have to create a summary of it."
                            },
                            "outputTokenLimit": {
                              "type": "integer",
                              "minimum": 1000,
                              "maximum": 10000,
                              "description": "The maximum length of a summary (in tokens)."
                            },
                            "generateMasterSummary": {
                              "type": "boolean",
                              "description": "Generate a summary of the entire file and index it as a standalone vector."
                            }
                          },
                          "additionalProperties": false
                        },
                        "vision": {
                          "type": "object",
                          "properties": {
                            "transcribePages": {
                              "description": "(Team/Enterprise plan only, charged as AI Spend) For PDF files, set this option to `true` or pass an array with specific page numbers to use a vision-enabled LLM to transcribe each page of the PDF as standalone vectors and index them.\n\nThis feature is useful when a PDF file contains custom designs or layouts, or when your document has many infographics, which require visual processing in order to index the file effectively, as the default text-based indexing may not be enough to allow your bot to correctly understand the content in your PDFs.\n\nNotes:\n- This feature is only available in Team and Enterprise plans.\n- Enabling this feature will incur in AI Spend cost to use a vision-enabled LLM to index the PDF pages.\n- This is limited to a maximum of 100 pages of the PDF. If the file has more pages then the rest of the pages will NOT be transcribed using this vision feature, and will be processed using the default text-based indexing instead. If you need to transcribe the entire file using vision, please split it into smaller files.\n- Pages that are vision-transcribed will not be processed by the default text-based indexing to avoid duplicate content in the index.\n- This feature is only available for PDF files. If the file isn't a PDF, this setting will be ignored and no AI Spend will be incurred."
                            },
                            "indexPages": {
                              "description": "(Team/Enterprise plan only, charged as AI Spend) For PDF files, set this option to `true` or pass an array with specific page numbers to use a vision-enabled LLM to index each page of the PDF as a standalone image.\n\nEnabling this feature will allow Autonomous Nodes in your bot to answer visual or higher-level questions about the content in these pages that can usually not be answered correctly by the default text-based indexing or visual transcription.\n\nThis feature is useful when a PDF has:\n- Tables with complex layouts\n- Charts, diagrams or infographics\n- Photos or images that can be used to answer user queries\n\nNotes:\n- This feature is only available in Team and Enterprise plans.\n- Enabling this will incur in extra AI Spend cost and additional File Storage usage, in order to use a vision-enabled LLM to visually index the PDF pages and store them as standalone page images in the bot's file storage.\n- Enabling this may increase the overall AI Spend cost of your bot as your bot may pass one or more indexed page images to a vision-enabled LLM for answering user queries.\n- This is limited to the first 100 pages of the PDF. If the file has more pages then the rest of the pages will NOT be vision-indexed. If you need to visually index the entire file, please split it into smaller files.\n- This feature is only available for PDF files. If the file isn't a PDF, this setting will be ignored and no AI Spend will be incurred."
                            }
                          },
                          "additionalProperties": false
                        }
                      },
                      "description": "Configuration to use for indexing the file, will be stored in the file's metadata for reference.",
                      "additionalProperties": false
                    }
                  },
                  "required": ["configuration"],
                  "additionalProperties": false
                },
                "accessPolicies": {
                  "type": "array",
                  "items": { "type": "string", "enum": ["public_content", "integrations"] },
                  "description": "File access policies. Add \"public_content\" to allow public access to the file content. Add \"integrations\" to allow read, search and list operations for any integration installed in the bot."
                },
                "contentType": {
                  "type": "string",
                  "description": "File content type. If omitted, the content type will be inferred from the file extension (if any) specified in `key`. If a content type cannot be inferred, the default is \"application/octet-stream\"."
                },
                "expiresAt": {
                  "type": "string",
                  "format": "date-time",
                  "description": "Expiry timestamp in ISO 8601 format with UTC timezone. After expiry, the File will be deleted. Must be in the future. Cannot be more than 90 days from now. The value up to minutes is considered. Seconds and milliseconds are ignored."
                },
                "publicContentImmediatelyAccessible": {
                  "type": "boolean",
                  "description": "Use when your file has \"public_content\" in its access policy and you need the file\\'s content to be immediately accessible through its URL after the file has been uploaded without having to wait for the upload to be processed by our system.\n\nIf set to `true`, the `x-amz-tagging` HTTP header with a value of `public=true` will need to be sent in the HTTP PUT request to the `uploadUrl` in order for the upload request to work."
                },
                "metadata": {
                  "description": "Custom metadata for the file expressed as an object of key-value pairs. The values can be of any type."
                }
              },
              "required": ["key", "size"],
              "title": "upsertFileBody",
              "additionalProperties": false
            }
          }
        }
      },
      "updateFileMetadataBody": {
        "description": "File metadata to update.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "metadata": {
                  "description": "Custom metadata for the file expressed as an object of key-value pairs. Omit to keep existing metadata intact. Any existing metadata keys not included will be preserved. New keys will be added. To delete a metadata key, set its value to `null`."
                },
                "tags": {
                  "type": "object",
                  "additionalProperties": { "type": "string", "maxLength": 1000, "nullable": true },
                  "description": "The file tags to update as an object of key-value pairs with `string` (text) values. Omit to keep existing tags intact. Any existing tags not included will be preserved. New tags will be added. To delete a tag, set its value to `null`."
                },
                "accessPolicies": {
                  "type": "array",
                  "items": { "type": "string", "enum": ["integrations", "public_content"] },
                  "description": "New access policies to set for the file. Omit to keep existing policies intact."
                },
                "expiresAt": {
                  "type": "string",
                  "format": "date-time",
                  "description": "Expiry timestamp in ISO 8601 format with UTC timezone. After expiry, the File will be deleted. Must be in the future. Cannot be more than 90 days from now. The value up to minutes is considered. Seconds and milliseconds are ignored. Omit to keep the existing expiry intact. Set to `null` to remove the expiry.",
                  "nullable": true
                }
              },
              "title": "updateFileMetadataBody",
              "additionalProperties": false
            }
          }
        }
      },
      "copyFileBody": {
        "description": "Additional options for file copying.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "overwrite": {
                  "type": "boolean",
                  "description": "Set to `true` to overwrite the file if it already exists, otherwise an error will be returned.\n\nWhen this endpoint is called using bot authentication, the existing file must have been originally created by the same bot making the file copy request in order to overwrite it."
                }
              },
              "title": "copyFileBody",
              "additionalProperties": false
            }
          }
        }
      },
      "createKnowledgeBaseBody": {
        "description": "Properties of the knowledge base.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": { "name": { "type": "string", "description": "Name of the knowledge base." } },
              "required": ["name"],
              "title": "createKnowledgeBaseBody",
              "additionalProperties": false
            }
          }
        }
      },
      "updateKnowledgeBaseBody": {
        "description": "Properties of the knowledge base to update.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": { "name": { "type": "string", "description": "New name of the knowledge base." } },
              "required": ["name"],
              "title": "updateKnowledgeBaseBody",
              "additionalProperties": false
            }
          }
        }
      }
    },
    "parameters": {}
  }
}
